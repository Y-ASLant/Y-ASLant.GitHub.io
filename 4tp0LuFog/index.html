<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>C语言超级无敌速成 - Note</title>
<link rel="shortcut icon" href="https://KA-ASLant.GitHub.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://KA-ASLant.GitHub.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://KA-ASLant.GitHub.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="C语言超级无敌速成 - Note - Atom Feed" href="https://KA-ASLant.GitHub.io/atom.xml">

<script async custom-element="amp-iframe"
  src="https://cdn.ampproject.org/v0/amp-iframe-0.1.js"></script>
  
    

  <meta name="description" content="      
使用内存
C被设计为一种低级语言，可以轻松访问内存位置并执行与内存相关的操作。
例如，scanf() 函数将用户输入的值放在变量的位置或地址处。这是通过使用＆符号实现的。
例如:
int num;
printf(&amp;quot;E..." />
  <meta property="og:title" content="C语言超级无敌速成 - Note">
  <meta property="og:description" content="      
使用内存
C被设计为一种低级语言，可以轻松访问内存位置并执行与内存相关的操作。
例如，scanf() 函数将用户输入的值放在变量的位置或地址处。这是通过使用＆符号实现的。
例如:
int num;
printf(&amp;quot;E..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://KA-ASLant.GitHub.io/4tp0LuFog/" />
  <meta property="og:image" content="https://KA-ASLant.GitHub.io/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="C语言超级无敌速成 - Note">
  <meta name="twitter:description" content="      
使用内存
C被设计为一种低级语言，可以轻松访问内存位置并执行与内存相关的操作。
例如，scanf() 函数将用户输入的值放在变量的位置或地址处。这是通过使用＆符号实现的。
例如:
int num;
printf(&amp;quot;E...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://KA-ASLant.GitHub.io/4tp0LuFog/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://KA-ASLant.GitHub.io/media/css/prism-atom-dark.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://KA-ASLant.GitHub.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      Note
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          C语言超级无敌速成
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2022年08月11日  Thursday · 56 min read</div>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <meta name="referrer" content="no-referrer" />      
<h2 id="使用内存">使用内存</h2>
<p>C被设计为一种低级语言，可以轻松访问内存位置并执行与内存相关的操作。</p>
<p>例如，scanf() 函数将用户输入的值放在变量的位置或地址处。这是通过使用＆符号实现的。</p>
<p>例如:</p>
<pre><code class="language-c">int num;
printf(&quot;Enter a number: &quot;);

scanf(&quot;%d&quot;, &amp;num);

printf(&quot;%d&quot;, num);
</code></pre>
<p>＆num是变量num的地址。</p>
<p>内存地址以十六进制数给出。十六进制，是一个基数为16的数字系统，它使用数字0到9和字母A到F（16个字符）代表一组四个二进制数字，其值可以从0到15。</p>
<p>读取32位内存的8位十六进制数字要比尝试破译32位1和0的二进制代码容易得多。</p>
<p>以下程序显示变量i和k的内存地址：</p>
<pre><code class="language-c">void test(int k);

int main() {
  int i = 0;
    
  printf(&quot;The address of i is %x\n&quot;, &amp;i);
  test(i);
  printf(&quot;The address of i is %x\n&quot;, &amp;i);
  test(i);

  return 0;
}

void test(int k) {
  printf(&quot;The address of k is %x\n&quot;, &amp;k);
}
</code></pre>
<p>在printf语句中，％x是十六进制格式说明符。</p>
<p>程序输出因运行会有所不同，但看起来类似于：</p>
<pre><code class="language-c">The address of i is 846dd754
The address of k is 846dd758
The address of i is 846dd754
The address of k is 846dd758
</code></pre>
<p>从变量声明到变量作用域结束的地址都保持不变。</p>
<h2 id="什么是指针">什么是指针？</h2>
<p>取地址运算符（&amp;）：返回操作数的内存地址。</p>
<p>解引用操作符（*）：返回位于操作数所指定地址的变量的值。</p>
<p>指针在C编程中非常重要，因为它们使你可以轻松地处理内存位置。</p>
<p>指针是数组，字符串以及其他数据结构和算法的基础。</p>
<p>指针是一个变量，其中包含另一个变量的地址。换句话说，它“指向”分配给变量的位置，并且可以间接访问该变量。</p>
<p>指针使用*符号声明，语法如下：</p>
<pre><code class="language-c">指针数据类型 *标识符 
</code></pre>
<p>实际的指针数据类型是十六进制数，但是在声明指针时，必须指出它将指向的数据类型。</p>
<p>星号 * 声明一个指针，并应出现在用于指针变量的标识符旁边。</p>
<p>以下程序演示了变量，指针和地址：</p>
<pre><code class="language-c">int j = 63;
int *p = NULL;
p = &amp;j; 

printf(&quot;The address of j is %x\n&quot;, &amp;j);
printf(&quot;p contains address %x\n&quot;, p);
printf(&quot;The value of j is %d\n&quot;, j);
printf(&quot;p is pointing to the value %d\n&quot;, *p); 
</code></pre>
<p>关于此程序，需要注意以下几点：</p>
<p>在将指针分配给有效位置之前，应将其初始化为NULL。</p>
<p>可以使用＆符号为指针分配变量的地址。</p>
<p>要查看指针指向的内容，请再次使用 *，如 *p 中所示。</p>
<p>在这种情况下，* 被称为间接或取消引用运算符。该过程称为取消引用。</p>
<p>程序输出类似于：</p>
<pre><code class="language-c">The address of j is ff3652cc
p contains address ff3652cc
The value of j is 63
p is pointing to the value 63 
</code></pre>
<blockquote>
<p>一些算法使用指向指针的指针。这种类型的变量声明使用**，并且可以分配另一个指针的地址，如下所示：</p>
<p>int x = 12;<br>
int *p = NULL<br>
int **ptr = NULL;<br>
p = &amp;x;<br>
ptr = &amp;p;</p>
</blockquote>
<h2 id="表达式中的指针">表达式中的指针</h2>
<p>指针可以与任何变量一样在表达式中使用。算术运算符可以应用于指针所指向的任何对象。</p>
<p>例如:</p>
<pre><code class="language-c">int x = 5;
int y;
int *p = NULL;
p = &amp;x;

y = *p + 2; /* y 被赋予 7 */
y += *p;     /* y 被赋予 12 */
*p = y;       /* x 被赋予 12 */
(*p)++;      /* x 增加到 13 */

printf(&quot;p指向值 %d\n&quot;, *p); 
</code></pre>
<p>运行结果:</p>
<pre><code class="language-c">p指向值 13
</code></pre>
<p>注意，++运算符需要括号才能增加所指向的值。使用--运算符时也是如此。</p>
<h2 id="指针和数组">指针和数组</h2>
<p>指针对于数组特别有用。</p>
<p>当定义各一个数组时, 系统会在内存中为该数组分配一个存储空间, 其数组的名称就是数组在内存中的首地址.若再定义各一个指针变量,并将数组的首地址传给指针变量,则该指针就指向了这个一维数组.</p>
<p>例如:</p>
<pre><code class="language-c">int *p, a[5];
p=a;
</code></pre>
<p>这里a是数组名, 也就是数组的<strong>首地址</strong>, 将它赋给指针变量p, 也就是将数组a的首地址赋给p.</p>
<p>也可以写成如下形式:</p>
<pre><code class="language-c">int *p, a[5];
p = &amp;a[0];
</code></pre>
<p>使用指针，我们可以指向第一个元素，然后使用地址算法遍历数组： +用于向前移动到存储位置   -用于向后移动到存储位置</p>
<pre><code class="language-c">int a[5] = {22, 33, 44, 55, 66};
int *ptr = NULL;
int i;

ptr = a;
for (i = 0; i &lt; 5; i++) {
  printf(&quot;%d &quot;, *(ptr + i));
}
</code></pre>
<p>程序输出为：22 33 44 55 66</p>
<p>数组的一个重要概念是，数组名称充当指向数组第一个元素的指针。</p>
<p><strong>因此，语句 ptr = a 可以认为是 ptr =＆a[0]。</strong></p>
<h2 id="更多地址算法">更多地址算法</h2>
<p>地址运算也可以视为指针运算，因为操作涉及指针。</p>
<p>除了使用+和–来引用下一个和上一个存储器位置之外，还可以使用赋值运算符更改指针包含的地址。</p>
<p>例如:</p>
<pre><code class="language-c">int a[5] = {22, 33, 44, 55, 66};
int *ptr = NULL;

ptr = a;  /* point to the first array element */
printf(&quot;%d  %x\n&quot;, *ptr, ptr);  /* 22 */
ptr++;
printf(&quot;%d  %x\n&quot;, *ptr, ptr);  /* 33 */
ptr += 3;
printf(&quot;%d  %x\n&quot;, *ptr, ptr);  /* 66 */
ptr--;
printf(&quot;%d  %x\n&quot;, *ptr, ptr);  /* 55 */
ptr -= 2;
printf(&quot;%d  %x\n&quot;, *ptr, ptr);  /* 33 */ 
</code></pre>
<p>程序输出类似于：</p>
<pre><code class="language-c">22 febd4760
33 febd4764
66 febd4770
55 febd476c
33 febd4764 
</code></pre>
<blockquote>
<p>你也可以使用 ==，&lt; 和 &gt; 运算符比较指针地址。</p>
</blockquote>
<h2 id="指针与函数">指针与函数</h2>
<p>指针大大扩展了功能的可能性。我们不再局限于返回一个值。使用指针参数，你的函数可以更改实际数据，而不是数据副本。</p>
<p>要更改变量的实际值，调用语句将地址传递给函数中的指针参数。</p>
<p>例如，以下程序交换两个值：</p>
<pre><code class="language-c">void swap (int *num1, int *num2);

int main() {
  int x = 25;
  int y = 100;

  printf(&quot;x is %d, y is %d\n&quot;, x, y); 
  swap(&amp;x, &amp;y);
  printf(&quot;x is %d, y is %d\n&quot;, x, y); 

  return 0;
}
 
void swap (int *num1, int *num2) {
  int temp;

  temp = *num1;
  *num1 = *num2;
  *num2 = temp;
}
</code></pre>
<p>程序交换变量的实际值，因为函数使用指针按地址访问它们。</p>
<h2 id="具有数组参数的函数">具有数组参数的函数</h2>
<p><strong>数组不能通过值传递给函数。但是，数组名是一个指针，因此仅将数组名传递给函数就是将指针传递给数组。</strong></p>
<p>例如:</p>
<pre><code class="language-c">int add_up (int *a, int num_elements);

int main() {
  int orders[5] = {100, 220, 37, 16, 98};

  printf(&quot;Total orders is %d\n&quot;, add_up(orders, 5)); 

  return 0;
}

int add_up (int *a, int num_elements) {
  int total = 0;
  int k;

  for (k = 0; k &lt; num_elements; k++) {
    total += a[k];
  }

  return (total);
} 
</code></pre>
<p>输出:</p>
<pre><code class="language-c">Total orders is 471
</code></pre>
<h2 id="返回数组的函数">返回数组的函数</h2>
<p>正如可以将指向数组的指针传递给函数一样，可以返回指向数组的指针，如以下程序所示：</p>
<pre><code class="language-c">int * get_evens();

int main() {
  int *a;
  int k;

  a = get_evens(); /* get first 5 even numbers */
  for (k = 0; k &lt; 5; k++)
    printf(&quot;%d\n&quot;, a[k]); 

  return 0;
}

int * get_evens() {
  static int nums[5];
  int k;
  int even = 0;

  for (k = 0; k &lt; 5; k++) {
    nums[k] = even += 2;
  }

  return (nums);
}
</code></pre>
<p>注意，声明了一个指针（而不是数组）来存储该函数返回的值。</p>
<p>还要注意，当从函数传递局部变量时，需要在函数中将其声明为静态变量。</p>
<p>请记住，a[k] 与 *(a + k)相同。</p>
<p>该代码的输出是什么？</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
int * test() {
static int x[4];
for(int i=0;i&lt;4;i++){
x[i] = i%2;
}
return x;
}

int main() {
int * arr = test();
printf(&quot;%d&quot;, *(arr+3));
}
</code></pre>
<pre><code class="language-c">输出结果为 1
</code></pre>
<h2 id="字符串">字符串</h2>
<p>C中的字符串是一个以NULL字符'\0'结尾的字符数组。</p>
<p>字符串声明可以通过多种方式进行，每种方式都有其各自的考虑因素。</p>
<p>例如:</p>
<pre><code>char str_name[str_len] = &quot;string&quot;; 
</code></pre>
<p>这将创建一个由str_len个字符组成的名为str_name的字符串，并将其初始化为值“ string”。</p>
<p>提供字符串文字以初始化字符串时，编译器会自动将NULL字符'\0'添加到char数组。</p>
<p>因此，必须声明数组大小至少比预期的字符串长度长一个字符。</p>
<p>下面的语句创建包含NULL字符的字符串。如果声明不包含char数组大小，则将根据初始化中字符串的长度加上'\0'的值来计算：</p>
<pre><code class="language-c">char str1[6] = &quot;hello&quot;;
char str2[ ] = &quot;world&quot;;  /* size 6 */
</code></pre>
<p>字符串也可以声明为一组字符：</p>
<pre><code class="language-c">char str3[6] = {'h', 'e', 'l', 'l', 'o', '\0'};
char str4[ ] = {'h', 'e', 'l', 'l', 'o', '\0'}; /* size 6 */ 
</code></pre>
<p>使用这种方法，必须显式添加NULL字符。注意，这些字符用单引号引起来。</p>
<p>与任何数组一样，字符串的名称充当指针。</p>
<p><strong>字符串</strong>文字是用<strong>双引号</strong>引起来的文本。</p>
<p>诸如 'b' 之类的<strong>字符</strong>用<strong>单引号</strong>引起来，不能视为字符串。</p>
<p>字符串指针声明，例如 char *str =&quot;stuff&quot;; 被认为是常量，不能从其初始值更改。</p>
<p>为了安全，方便地使用字符串，可以使用下面显示的“标准库”字符串函数。不要忘记引入&lt;string.h&gt;头文件。</p>
<blockquote>
<p>strlen() -获取字符串的长度</p>
<p>strcat()-合并两个字符串</p>
<p>strcpy()-将一个字符串复制到另一个</p>
<p>strlwr()-将字符串转换为小写</p>
<p>trupr()-将字符串转换为大写</p>
<p>strrev()-反向字符串</p>
<p>strcmp()-比较两个字符串</p>
</blockquote>
<h2 id="字符串输入">字符串输入</h2>
<p>程序通常是交互式的，要求用户输入。</p>
<p>为了从用户那里检索一行文本或其他字符串，C提供了scanf()，gets()和fgets()函数。</p>
<p>你可以使用scanf()根据格式说明符读取输入。</p>
<p>例如:</p>
<pre><code class="language-c">char first_name[25];
int age;
printf(&quot;Enter your first name and age: \n&quot;);
scanf(&quot;%s %d&quot;, first_name, &amp;age); 
</code></pre>
<p>当使用scanf()读取字符串时，不需要＆访问变量地址，因为数组名称充当指针。</p>
<p>scanf()到达空格时停止读取输入。</p>
<p>要读取带空格的字符串，请使用gets()函数。它读取输入，直到到达终止换行符（按Enter键）。</p>
<p>例如:</p>
<pre><code class="language-c">char full_name[50];
printf(&quot;Enter your full name: &quot;);
gets(full_name);
</code></pre>
<p>gets()的更安全替代方法是fgets()，它最多读取指定数量的字符。</p>
<p>这种方法有助于防止缓冲区溢出（当字符串数组的大小不足以容纳键入的文本时发生）。</p>
<p>例如:</p>
<pre><code class="language-c">char full_name[50];
printf(&quot;Enter your full name: &quot;);
fgets(full_name, 50, stdin);
</code></pre>
<p>fgets() 参数是字符串名称，要读取的字符数以及指向要从中读取字符串的指针。 stdin表示从标准输入（即键盘）中读取。</p>
<p>get 和 fgets 之间的另一个区别是换行符由fgets存储。</p>
<blockquote>
<p>fgets() 仅从stdin读取n-1个字符，因为必须有用于'\0'的空间。</p>
</blockquote>
<h2 id="字符串输出">字符串输出</h2>
<p>字符串输出由fputs()，putf()和printf()函数处理。</p>
<p><strong>fputs 函数</strong></p>
<p>fputs 函数的作用是想指定的文件写入一个字符串，其中字符串可以是字符串常量，也可以是字符组名、指针或变量。</p>
<p>fputs 一般形式如下：</p>
<pre><code class="language-c">fputs(字符串, 文件指针)
</code></pre>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  FILE *wj=NULL;
  wj=fopen(&quot;E:\\文件夹1\\生成.txt&quot;,&quot;w+&quot;)
  char city[40];
  printf(&quot;Enter your favorite city: &quot;);
  gets(city);
    //fgets(要写入的数组，大小，要读取的文件)//一般用法
  // fgets(city, 40, stdin);//从stdin输入中读取40位写入city数组中 此用法与gets（city）同义
//超过40位以外的不读取！！
  fputs(city, wj);//将city里的数据写入到wj
    puts(city);//在终端显示city里面的数据
   // fputs(city,stdout);//与puts相同
  printf(&quot; is a fun city.&quot;);

  return 0;
}
</code></pre>
<p>puts() 函数仅接受字符串参数，也可以用于显示输出。</p>
<p>但是，puts() 将在输出中添加换行符。</p>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  char city[40];
  printf(&quot;Enter your favorite city: &quot;);
  gets(city);
  // Note: for safety, use
  // fgets(city, 40, stdin);

  puts(city);

  return 0;
}
</code></pre>
<h2 id="sprintf-和-sscanf-函数">sprintf 和 sscanf 函数</h2>
<p>可以使用 sprintf() 函数创建格式化的字符串。这对于用其他数据类型来构建字符串很有用。</p>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  char info[100];
  char dept[ ] = &quot;HR&quot;;
  int emp = 75;
  sprintf(info, &quot;The %s dept has %d employees.&quot;, dept, emp);
  printf(&quot;%s\n&quot;, info);

  return 0;
}
</code></pre>
<p>结果是:</p>
<pre><code class="language-c">The HR dept has 75 employees.
</code></pre>
<p>另一个有用的函数是 sscanf()，用于扫描字符串中的值。</p>
<p>该函数从字符串中读取值，并将其存储在相应的变量地址中。</p>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  char info[ ] = &quot;Snoqualmie WA 13190&quot;;
  char city[50];
  char state[50];
  int population;
  sscanf(info, &quot;%s %s %d&quot;, city, state, &amp;population);
  printf(&quot;%d people live in %s, %s.&quot;, population, city, state);

  return 0;
}
</code></pre>
<p>结果是:</p>
<pre><code class="language-c">13190 people live in Snoqualmie, WA.
</code></pre>
<h2 id="stringh库字符串函数">string.h库（字符串函数）</h2>
<p>string.h库包含许多字符串函数。</p>
<p>程序顶部使用语句#include &lt;string.h&gt;使你可以访问以下内容：</p>
<ul>
<li>
<p>strlen(str) 返回存储在str中的字符串的长度，不包括NULL字符。</p>
</li>
<li>
<p>strcat(str1, str2) 将str2追加（连接）到str1的末尾，并返回指向str1的指针。</p>
</li>
<li>
<p>strcpy(str1, str2) 将str2复制(<strong>覆盖</strong>)到str1。此功能对于为字符串分配新值很有用。</p>
</li>
<li>
<p>strncat(str1, str2, n) 将str2的前n个字符追加（连接）到str1的末尾，并返回指向str1的指针。</p>
</li>
<li>
<p>strncpy(str1, str2, n) 将str2的前n个字符复制(<strong>覆盖</strong>)到str1。</p>
</li>
<li>
<p>strcmp(str1, str2) 当str1等于str2时返回0，在 str1 &lt;str2 时返回小于0，在 str1&gt; str2 时返回大于0。</p>
</li>
<li>
<p>strncmp(str1, str2, n) 当str1的前n个字符等于str2的前n个字符时，返回0；当str1 &lt;str2时，小于0；当str1&gt; str2时，大于0。</p>
</li>
<li>
<p>strchr(str1, c) 返回指向str1中首次出现的char c的指针，如果找不到字符，则返回NULL。</p>
</li>
<li>
<p>strrchr(str1,c) 反向搜索str1并返回一个指向char c在str1中位置的指针；如果找不到字符，则返回NULL。</p>
</li>
<li>
<p>strstr(str1,str2) 返回指向str1中首次出现的str2的指针，如果未找到str2，则返回NULL。</p>
</li>
</ul>
<p>下面的程序演示了string.h函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char s1[ ] = &quot;The grey fox&quot;;
  char s2[ ] = &quot; jumped.&quot;;
    
  strcat(s1, s2);
  printf(&quot;%s\n&quot;, s1);
  printf(&quot;Length of s1 is %d\n&quot;, strlen(s1));
  strcpy(s1, s2);
  printf(&quot;s1 is now %s \n&quot;, s1);

  return 0;
}
</code></pre>
<p>运行结果:</p>
<pre><code class="language-c">The grey fox jumped.
Length of s1 is 20
s1 is now  jumped. 
</code></pre>
<h2 id="将字符串转换为数字">将字符串转换为数字</h2>
<p>将数字字符串转换为数值是C编程中的常见任务，通常用于防止运行时错误。</p>
<p>读取字符串比期望数值更容易出错，用户可能不小心键入“ o”而不是“ 0”（零）。</p>
<p>stdio.h库包含以下用于将字符串转换为数字的函数：</p>
<ul>
<li>
<p>int atoi(str) 代表ASCII转成整数。将str转换为等效的int值。<strong>如果第一个字符不是数字或未遇到任何数字，则返回0。</strong></p>
</li>
<li>
<p>double atof(str)表示ASCII转成浮动。将str转换为等效的double值。<strong>如果第一个字符不是数字或未遇到数字，则返回0.0。</strong></p>
</li>
<li>
<p>long int atol(str) 表示ASCII转成long int。将str转换为等效的长整数值。<strong>如果第一个字符不是数字或未遇到任何数字，则返回0。</strong></p>
</li>
</ul>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
{
  char input[10];
  int num;
    
  printf(&quot;Enter a number: &quot;);
  gets(input);
  num = atoi(input);

  return 0;
}
</code></pre>
<p>注意，atoi() 缺少错误处理，如果要确保已完成正确的错误处理，建议使用strtol()。</p>
<h2 id="字符串数组">字符串数组</h2>
<p>二维数组可用于存储相关的字符串。</p>
<p>以下语句，该语句声明一个包含3个元素的数组，每个元素包含15个字符：</p>
<pre><code class="language-c">char trip[3][15] = {
  &quot;suitcase&quot;,
  &quot;passport&quot;,
  &quot;ticket&quot;
};
</code></pre>
<p>尽管字符串长度有所不同，但必须声明一个足够大的大小以容纳最长的字符串。另外，访问这些元素可能非常麻烦。</p>
<p>引用trip[0]表示“suitcase”容易出错。相反，你必须将[0][0]处的元素视为“ s”，将[2][3]处的元素视为“ k”，依此类推。</p>
<p>处理相关字符串集合的一种更简单，更直观的方法是使用指针数组，如以下程序所示：</p>
<pre><code class="language-c">char *trip[ ] = {
  &quot;suitcase&quot;,因为每个元素的长度都可以变化，所以与二维网格结构相比，字符串指针数组的结构更加参差不齐。
  &quot;passport&quot;,
  &quot;ticket&quot;
};

printf(&quot;Please bring the following:\n&quot;);
for (int i = 0; i &lt; 3; i++) {
  printf(&quot;%s\n&quot;, trip[ i ]);
}
</code></pre>
<p>因为每个元素的长度都可以变化，所以与二维网格结构相比，字符串指针数组的结构更加参差不齐。</p>
<p>使用这种方法，字符串长度没有限制。更重要的是，可以通过指向每个字符串的第一个字符的指针来引用项目。</p>
<p>请记住，像 char * items [3]; 这样的声明；仅保留三个指针的空间；这些指针引用了实际的字符串。</p>
<h2 id="函数指针">函数指针</h2>
<p>由于指针可以指向任何存储器位置中的地址，因此它们也可以指向可执行代码的开头。</p>
<p>函数指针或函数指针指向内存中函数的可执行代码。函数指针可以存储在数组中，也可以作为参数传递给其他函数。</p>
<p>函数指针声明使用 * 就像使用任何指针一样：</p>
<pre><code class="language-c">return_type (*函数名)(参数) 
</code></pre>
<p>(*函数名) 周围的括号很重要。没有括号，编译器会认为函数在返回指针。</p>
<p><strong>声明函数指针后，必须将其分配给函数。</strong></p>
<p>下面的简短程序声明一个函数，声明一个函数指针，将该函数指针分配给该函数，然后通过该指针调用该函数：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
void say_hello(int num_times); /* function */

int main() {
  void (*funptr)(int);  /* function pointer */
  funptr = say_hello;  /* 看注意 */
  funptr(3);  /* function call */
    
  return 0;
}

void say_hello(int num_times) {
  int k;
  for (k = 0; k &lt; num_times; k++)
    printf(&quot;Hello\n&quot;);
}
</code></pre>
<p><strong>注意</strong>：</p>
<p>函数名称指向可执行代码的开头，就像数组名称指向其第一个元素一样。</p>
<p>因此，尽管诸如 <strong>funptr = &amp;say_hello</strong> 和 <strong>(*funptr)(3)</strong> 之类的语句是正确的，但在函数分配和函数调用中<strong>不必包括地址运算符＆和间接运算符</strong>*。</p>
<h2 id="函数指针数组">函数指针数组</h2>
<p>函数指针数组可以替换开关或if语句以选择动作，如以下程序所示：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int add(int num1, int num2);
int subtract(int num1, int num2);
int multiply(int num1, int num2);
int divide(int num1, int num2);

int main() 
{
  int x, y, choice, result;
  int (*op[4])(int, int);

  op[0] = add;
  op[1] = subtract;
  op[2] = multiply;
  op[3] = divide;
  printf(&quot;Enter two integers: &quot;);
  scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
  printf(&quot;Enter 0 to add, 1 to subtract, 2 to multiply, or 3 to divide: &quot;);
  scanf(&quot;%d&quot;, &amp;choice);
  result = op[choice](x, y);
  printf(&quot;%d&quot;, result);
    
  return 0;
}

int add(int x, int y) {
  return(x + y);
}

int subtract(int x, int y) {
  return(x - y);
}

int multiply(int x, int y) {
  return(x * y);
}

int divide(int x, int y) {
  if (y != 0)
    return (x / y);
  else
    return 0;
}
</code></pre>
<p><strong>int (*op[4])(int, int);</strong> 语句声明函数指针的数组。每个数组元素必须具有相同的参数和返回类型。</p>
<p>在这种情况下，分配给数组的函数具有两个int参数并返回一个int。</p>
<h2 id="空指针">空指针</h2>
<p>空指针用于引用内存中的任何地址类型，并具有类似于以下内容的声明：</p>
<pre><code class="language-c">void *ptr;
</code></pre>
<p>以下程序将相同的指针用于三种不同的数据类型：</p>
<pre><code class="language-c">int x = 33;
float y = 12.4;
char c = 'a';
void *ptr;
  
ptr = &amp;x;
printf(&quot;void ptr points to %d\n&quot;, *((int *)ptr));
ptr = &amp;y;
printf(&quot;void ptr points to %f\n&quot;, *((float *)ptr));
ptr = &amp;c;
printf(&quot;void ptr points to %c&quot;, *((char *)ptr));
</code></pre>
<ul>
<li>
<p>*<em>(int <em>)ptr是表示把ptr强制转换成一个int型的指针。</em></em></p>
</li>
<li>
<p>**<em>(int <em>)ptr就是取ptr指向的内容的意思，跟*ptr的那个*作用一样</em></em></p>
</li>
<li>
<p>**void指针可以保存各种其它指针类型。**大多数时候它被用来存储数据结构。</p>
</li>
</ul>
<p>取消引用空指针时，必须先使用类型将指针转换为适当的数据类型，然后再使用*取消引用。</p>
<blockquote>
<p><strong>不能使用空指针执行指针运算。</strong></p>
</blockquote>
<h2 id="使用空指针的函数">使用空指针的函数</h2>
<p>空指针通常用于函数声明。</p>
<p>例如:</p>
<pre><code class="language-c">void * square (const void *); 
</code></pre>
<p><strong>使用 void * 返回类型允许任何返回类型。同样，void * 的参数可以接受任何参数类型。</strong></p>
<p>如果要使用参数传递的数据而不更改它，则将其声明为<code>const</code>。</p>
<p>你可以省略参数名称，以进一步使声明与其实现的隔离。通过这种方式声明一个函数，可以根据需要自定义，而不必更改声明。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void* square (const void* num);

int main() {
  int x, sq_int;
  x = 6;
  sq_int = square(&amp;x);
  printf(&quot;%d squared is %d\n&quot;, x, sq_int);

  return 0;
}

void* square (const void *num) {
  int result;
  result = (*(int *)num) * (*(int *)num);
  return result;
}
</code></pre>
<p><strong>square 函数需要 int 类型，这就是为什么将num void指针强制转换为int的原因。</strong></p>
<h2 id="函数指针作为参数">函数指针作为参数</h2>
<p>使用函数指针的另一种方法是将其作为参数传递给另一个函数。</p>
<p>用作参数的函数指针有时称为回调函数，因为接收函数会“回调它”。</p>
<p>stdlib.h头文件中的 qsort() 函数使用此技术。</p>
<p>quicksort是一种广泛用于对数组进行排序的算法。</p>
<p>要在程序中实现排序，只需包含stdlib.h文件，然后编写一个与qsort中使用的声明匹配的比较函数：</p>
<p>函数声明:</p>
<pre><code class="language-c">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
</code></pre>
<p>qsort声明解释：</p>
<p>base 指向要排序的数组的第一个元素的指针。。</p>
<p>nitems 由 base 指向的数组中元素的个数。</p>
<p>size 数组中每个元素的大小，以字节为单位。</p>
<p>compar 用来比较两个元素的函数，即函数指针（回调函数）</p>
<p><strong>回调函数：</strong></p>
<p>回调函数就是一个通过函数指针调用的函数。如果把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就说这是回调函数。</p>
<p><strong>compar参数</strong></p>
<p>compar参数指向一个比较两个元素的函数。比较函数的原型应该像下面这样。注意两个形参必须是const void *型，同时在调用compar 函数（compar实质为函数指针，这里称它所指向的函数也为compar）时，传入的实参也必须转换成const void *型。在compar函数内部会将const void *型转换成实际类型。</p>
<p>​       int compar(const void *p1, const void *p2);</p>
<p>​       如果compar返回值小于0（&lt; 0），那么p1所指向元素会被排在p2所指向元素的左面；</p>
<p>如果compar返回值等于0（= 0），那么p1所指向元素与p2所指向元素的顺序不确定；</p>
<p>如果compar返回值大于0（&gt; 0），那么p1所指向元素会被排在p2所指向元素的右面。</p>
<p>以下程序使用qsort从低到高对一个整数数组进行排序：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int compare (const void *, const void *); 

int main() {
  int arr[5] = {52, 23, 56, 19, 4};
  int num, width, i;
  
  num = sizeof(arr)/sizeof(arr[0]);
  width = sizeof(arr[0]);
  qsort((void *)arr, num, width, compare);
  for (i = 0; i &lt; 5; i++)
    printf(&quot;%d &quot;, arr[ i ]);
    
  return 0;
}

int compare (const void *elem1, const void *elem2) {
  if ((*(int *)elem1) == (*(int *)elem2))
    return 0;
  else if ((*(int *)elem1) &lt; (*(int *)elem2))
    return -1;
  else
    return 1;
}
</code></pre>
<p>我们在qsort调用中使用了函数名，因为函数名充当了指针。用作参数的函数指针有时称为：回调函数。</p>
<h2 id="结构体">结构体</h2>
<p>在一些情况下，程序员可以将一些有关的变量组织起来定义成一个结构， 这样来表示一个有机的整体或一个新的类型，因此程序就可以像处理内部的基本数据那样对结构进行各种操作。</p>
<p>“结构体”是一种构造类型，它是由若干“成员”组成的，其中的每一个成员可以是一个基本数据类型或者又是一个构造类型。既然结构体是一种新的类型，就需要先对其进行构造，这里这种操作称为声明一个结构体。</p>
<p>声明结构体的过程就好比生产商品的过程，只有商品生产出来才可以使用该商品。</p>
<p>加入在程序中使用“商品”这样一个类型，一般的商品具有产品名称，形状，颜色，功能，价格和产地等。</p>
<figure data-type="image" tabindex="1"><img src="https://i0.hdslb.com/bfs/album/08ff81b80c59ba5ab3e525f57e63188032be16ee.png" alt="" loading="lazy"></figure>
<p>声明结构体时使用的关键字是 struct， 其一般形式为：</p>
<pre><code class="language-c">struct 结构体名
{
     成员列表
}
</code></pre>
<p>例如：</p>
<pre><code class="language-c">struct course {
  int id;
  char title[40];
  float hours; 
}; 
</code></pre>
<p>此struct语句定义了一个新的数据类型，命名为course，它具有三个成员。</p>
<p>结构成员可以是任何数据类型，包括基本类型，字符串，数组，指针，甚至其他结构。</p>
<blockquote>
<p>不要忘了在结构声明后加上分号。</p>
<p>结构也称为复合或聚合数据类型。</p>
</blockquote>
<h2 id="结构体变量的定义">结构体变量的定义</h2>
<p>要声明结构数据类型的变量，请使用关键字struct，后跟struct标记，然后变量名。</p>
<p>例如，下面的语句声明一个结构数据类型，然后使用Student结构声明变量s1和s2：</p>
<pre><code class="language-c">struct student {
  int age;
  int grade;
  char name[40];
};

/* declare two variables */
struct student s1;
struct student s2; 
</code></pre>
<blockquote>
<p>结构变量存储在连续的内存块中。就像基本数据类型一样，必须使用sizeof运算符来获取结构所需的字节数。</p>
</blockquote>
<h2 id="声明结构体变量">声明结构体变量</h2>
<p>也可以在声明中通过在花括号内按顺序列出初始值来初始化struct变量：</p>
<pre><code class="language-c">struct student s1 = {19, 9, &quot;John&quot;};
struct student s2 = {22, 10, &quot;Batman&quot;};
</code></pre>
<p>如果要在声明后使用花括号初始化结构，则还需要写明类型转换，如以下语句所示：</p>
<pre><code class="language-c">struct student s1;
s1 = (struct student) {19, 9, &quot;John&quot;};
</code></pre>
<p>初始化结构相应成员：</p>
<pre><code class="language-c">struct student s1 
= { .grade = 9, .age = 19, .name = &quot;John&quot;}; 
</code></pre>
<p>在上面的示例中，.grade表示结构体的grade成员。同理 .age 和 .name 对应结构体 age 和 name 成员。</p>
<h2 id="结构体变量的引用">结构体变量的引用</h2>
<p>你可以使用 **.（点运算符）**来访问struct变量的成员。</p>
<p>语法:</p>
<pre><code class="language-c">结构体变量.成员名
</code></pre>
<p>例如，要将值分配给s1结构变量age成员：</p>
<pre><code class="language-c">s1.age = 19;
</code></pre>
<p>你还可以将一个结构分配给相同类型的另一个结构：</p>
<pre><code class="language-c">struct student s1 = {19, 9, &quot;Jason&quot;};
struct student s2;
//....
s2 = s1; 
</code></pre>
<p>以下代码演示了如何使用结构：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct course {
  int id;
  char title[40];
  float hours; 
};

int main() {
  struct course cs1 = {341279, &quot;Intro to C++&quot;, 12.5};
  struct course cs2;

  /* initialize cs2 */
  cs2.id = 341281;
  strcpy(cs2.title, &quot;Advanced C++&quot;);
  cs2.hours = 14.25;
   
  /* display course info */
  printf(&quot;%d\t%s\t%4.2f\n&quot;, cs1.id, cs1.title, cs1.hours);
  printf(&quot;%d\t%s\t%4.2f\n&quot;, cs2.id, cs2.title, cs2.hours);
  
  return 0;
}
</code></pre>
<p>字符串分配需要使用 string.h 库中的strcpy()。</p>
<h2 id="使用typedef">使用typedef</h2>
<p>typedef关键字 创建一个类型定义，该定义可简化代码并使程序更易于阅读。</p>
<p>typedef 通常与结构一起使用，因为它消除了在声明变量时使用关键字struct的需要。</p>
<p>例如:</p>
<pre><code class="language-c">typedef struct {
  int id;
  char title[40];
  float hours; 
} course;

course cs1;
course cs2; 
</code></pre>
<p>注意，不再使用结构标签，而是在结构声明之前显示typedef名称。</p>
<p>现在，变量声明中不再需要使用struct一词，从而使代码更简洁，更易于阅读。</p>
<h2 id="结构与结构">结构与结构</h2>
<p>结构的成员也可以是结构。</p>
<p>例如:</p>
<pre><code class="language-c">typedef struct {
  int x;
  int y;
} point;

typedef struct {
  float radius;
  point center;
} circle; 
</code></pre>
<p>嵌套花括号用于初始化结构成员。点运算符两次用于访问成员的成员，如语句中所示：</p>
<pre><code class="language-c">circle c = {4.5, {1, 3}};
printf(&quot;%3.1f %d,%d&quot;, c.radius, c.center.x, c.center.y);
/* 4.5  1,3 */
</code></pre>
<blockquote>
<p>必须先出现一个结构定义，然后才能在另一个结构中使用它。</p>
</blockquote>
<h2 id="指向结构的指针">指向结构的指针</h2>
<p>像指向变量的指针一样，也可以定义指向结构的指针。</p>
<pre><code class="language-c">struct myStruct *struct_ptr;
</code></pre>
<p>定义一个指向myStruct结构的指针。</p>
<pre><code class="language-c">struct_ptr = &amp;struct_var;
</code></pre>
<p>将结构变量 struct_var 的地址存储在指针struct_ptr中。</p>
<pre><code class="language-c">struct_ptr -&gt; struct_mem;
</code></pre>
<p>访问结构成员struct_mem的值。</p>
<p>例如:</p>
<pre><code class="language-c">struct student{
  char name[50];
  int number;
  int age;
};

// Struct pointer as a function parameter
void showStudentData(struct student *st) {
  printf(&quot;\nStudent:\n&quot;);
  printf(&quot;Name: %s\n&quot;, st-&gt;name);
  printf(&quot;Number: %d\n&quot;, st-&gt;number);
  printf(&quot;Age: %d\n&quot;, st-&gt;age);
}

struct student st1 = {&quot;Krishna&quot;, 5, 21};
showStudentData(&amp;st1);
</code></pre>
<p><strong>-&gt; 运算符允许通过指针访问结构的成员。</strong></p>
<blockquote>
<p><strong>(*st).age</strong>与st-&gt;age相同。<br>
同样，当使用typedef命名结构时，仅使用typedef名称以及*和指针名称来声明指针。</p>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://i0.hdslb.com/bfs/album/b51974a6b5ba338fc3ce5348e3015d0459e72d51.png" alt="" loading="lazy"></figure>
<h2 id="结构作为函数参数">结构作为函数参数</h2>
<p>一个函数可以具有结构参数，当仅需要结构变量的副本时，该结构参数将按值接受参数。</p>
<p>要使函数更改struct变量中的实际值，则需要使用指针参数。</p>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct {
  int id;
  char title[40];
  float hours; 
} course;

void update_course(course *class);
void display_course(course class);

int main() {
  course cs2;
  update_course(&amp;cs2);
  display_course(cs2);
  return 0;
}

void update_course(course *class) {
  strcpy(class-&gt;title, &quot;C++ Fundamentals&quot;);
  class-&gt;id = 111;
  class-&gt;hours = 12.30;
}

void display_course(course class) {
  printf(&quot;%d\t%s\t%3.2f\n&quot;, class.id, class.title, class.hours);
}
</code></pre>
<p>如你所见，update_course() 将指针作为参数，而display_course()将按值获取结构。</p>
<figure data-type="image" tabindex="3"><img src="https://i0.hdslb.com/bfs/album/bea9d35c8f7d7eb7bf2a3e9fcbbccd4fbbc4188a.png" alt="" loading="lazy"></figure>
<h2 id="结构数组">结构数组</h2>
<p>数组可以存储任何数据类型的元素，包括结构。</p>
<p>声明结构数组后，可以使用索引号访问元素。</p>
<p>然后使用点运算符访问元素的成员，如程序中所示：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

typedef struct {
  int h;
  int w;
  int l;
} box;

int main() {
  box boxes[3] = {{2, 6, 8}, {4, 6, 6}, {2, 6, 9}};
  int k, volume;
  
  for (k = 0; k &lt; 3; k++) {
    volume = boxes[k].h*boxes[k].w*boxes[k].l;
    printf(&quot;box %d volume %d\n&quot;, k, volume);
  }
  return 0;
}
</code></pre>
<p>结构数组用于数据结构，例如链表，二进制树等。</p>
<figure data-type="image" tabindex="4"><img src="https://i0.hdslb.com/bfs/album/692cc5b5664127467afcd18023d14e0c4e9f3b40.png" alt="" loading="lazy"></figure>
<h2 id="共用体">共用体</h2>
<p>共用体看起来像结构体，只不过关键字由struct变成了union。</p>
<ul>
<li>
<p><strong>共用体和结构体的区别在于：结构体定义了一个由多个数据成员组成的特殊类型，而共用体定义了一块为所有数据成员共享的内存。</strong></p>
</li>
<li>
<p><strong>共用体也称为联合体，它使几种不同类型的变量存放到同一段内存单元中。所以共用体在同一时刻只能有一个值，它属于某一个数据成员。由于所有成员位于同一块内存，因此共用体的大小就等于最大成员的大小。</strong></p>
</li>
</ul>
<p>定义共用体的类型变量一般形式为：</p>
<pre><code class="language-c">union 共用体名
{
    成员列表
}变量列表;
</code></pre>
<p>例如:</p>
<pre><code class="language-c">union val {
  int int_num;
  float fl_num;
  char str[20]; 
};
</code></pre>
<p>声明 union(共用体) 之后，可以声明 union(共用体) 变量。你甚至可以将一个共用体分配给另一个相同类型的共用体(联合体)：</p>
<pre><code class="language-c">union val u1;
union val u2;
u2 = u1; 
</code></pre>
<h2 id="访问共用体成员">访问共用体成员</h2>
<p>你可以使用 . (点符号) 来访问共用体的成员。</p>
<p>语法：</p>
<pre><code class="language-c">共用体变量.成员名
</code></pre>
<p>尝试访问不占用内存位置的成员会产生意外的结果。</p>
<p>以下程序演示了如何访问共用体成员：</p>
<pre><code class="language-c">union val {
  int int_num;
  float fl_num;
  char str[20]; 
};
  
union val test;

test.int_num = 123;
test.fl_num = 98.76;
strcpy(test.str, &quot;hello&quot;);

printf(&quot;%d\n&quot;, test.int_num);
printf(&quot;%f\n&quot;, test.fl_num);
printf(&quot;%s\n&quot;, test.str);
</code></pre>
<p>结果:</p>
<pre><code class="language-c">1819043176
1143141483620823940762435584.000000
hello
</code></pre>
<p>最后一个赋值将覆盖先前的赋值，这就是为什么str存储一个值并且访问int_num和fl_num毫无意义的原因。</p>
<h2 id="结构体内共用体">结构体内共用体</h2>
<p>因为在结构中可以具有一个成员来跟踪哪个联合成员存储值，所以通常在结构内使用联合。</p>
<p>例如，在以下程序中，车辆结构使用车辆识别号（VIN）或分配的ID，但不能同时使用两者：</p>
<pre><code class="language-c">typedef struct {
  char make[20];
  int model_year;
  int id_type; /* 0 for id_num, 1 for VIN */
  union {
    int id_num;
    char VIN[20]; 
  } id;
} vehicle;

vehicle car1;
strcpy(car1.make, &quot;Ford&quot;);
car1.model_year = 2017;
car1.id_type = 0;
car1.id.id_num = 123098; 
</code></pre>
<p>注意，<strong>该联合在结构内部声明</strong>。</p>
<p>这样做时，声明的末尾需要一个联合名(共用体名)。</p>
<p>id_type跟踪哪个联合成员存储一个值。以下语句显示car1数据，并使用id_type确定要读取的联合成员：</p>
<pre><code class="language-c">/* display vehicle data */
printf(&quot;Make: %s\n&quot;, car1.make);
printf(&quot;Model Year: %d\n&quot;, car1.model_year);
if (car1.id_type == 0)
  printf(&quot;ID: %d\n&quot;, car1.id.id_num);
else
  printf(&quot;ID: %s\n&quot;, car1.id.VIN); 
</code></pre>
<p><strong>共用体也可以包含结构。</strong></p>
<h2 id="共用体指针">共用体指针</h2>
<p><strong>指向共用体的指针指向分配给共用体的内存位置。</strong></p>
<p>通过使用关键字 union 和 union 标签以及*和指针名称来声明共用体指针。</p>
<p>例如:</p>
<pre><code class="language-c">union val {
  int int_num;
  float fl_num;
  char str[20]; 
};

union val info;
union val *ptr = NULL;
ptr = &amp;info;
ptr-&gt;int_num = 10;
printf(&quot;info.int_num is %d&quot;, info.int_num); 
</code></pre>
<p>如果要通过指针访问共用体成员，则需要-&gt;运算符。</p>
<blockquote>
<p>(*ptr).int_num 与 ptr-&gt;int_num 相同</p>
</blockquote>
<h2 id="共用体作为函数参数">共用体作为函数参数</h2>
<p>一个函数可以具有共用体参数，当需要共用体变量的副本时，该参数可以按值接受参数。</p>
<p>函数要更改共用体存储位置中的实际值，需要使用指针参数。</p>
<p>例如:</p>
<pre><code class="language-c">union id {
  int id_num;
  char name[20]; 
};

void set_id(union id *item) {
  item-&gt;id_num = 42;
}

void show_id(union id item) {
  printf(&quot;ID is %d&quot;, item.id_num);
} 
</code></pre>
<h2 id="共用体数组">共用体数组</h2>
<p><strong>数组可以存储任何数据类型的元素</strong>，包括共用体。</p>
<p><strong>使用共用体时，请记住，共用体中只有一个成员可以存储每个数组元素的数据，这一点很重要。</strong></p>
<p>在声明共用体数组之后，可以使用索引号访问元素。然后使用点运算符访问共用体(联合)的成员，如程序中所示：</p>
<pre><code class="language-c">union val {
  int int_num;
  float fl_num;
  char str[20]; 
};

union val nums[10];
int k;

for (k = 0; k &lt; 10; k++) {
  nums[k].int_num = k;
}

for (k = 0; k &lt; 10; k++) {
  printf(&quot;%d  &quot;, nums[k].int_num);
} 
</code></pre>
<p>数组是一种数据结构，用于存储所有相同类型的集合值。</p>
<p>共同体数组允许存储不同类型的值。</p>
<p>例如:</p>
<pre><code class="language-c">union type {
  int i_val;
  float f_val;
  char ch_val;
};
union type arr[3];
arr[0].i_val = 42;
arr[1].f_val = 3.14;
arr[2].ch_val = 'x'; 
</code></pre>
<p><img src="https://i0.hdslb.com/bfs/album/37925ec1cff805e67086514e249499ae189abc99.png" alt="" loading="lazy"><br>
<img src="https://i0.hdslb.com/bfs/album/a4d1ac136ea93887c5b4ee97856ac8e19cdccb12.png" alt="" loading="lazy"><br>
<img src="https://i0.hdslb.com/bfs/album/9e714c9085cab2248d4326a636062babd3be3c82.png" alt="" loading="lazy"></p>
<h2 id="内存管理">内存管理</h2>
<p>内存的组织方式</p>
<p>开发人员将程序编写完成后，程序要先转载到计算机的内核或者半导体内存中，再运行程序。</p>
<p>程序被组织成一下4个逻辑段:</p>
<p>可执行代码</p>
<p>静态数据。可执行代码和静态数据存储的内存位置。</p>
<p>动态数据（堆）。程序请求动态分配的内存来自内存池。</p>
<p>栈。局部数据对象、函数的参数以及调用函数和被调用函数的联系放在称之为栈的内存池中。</p>
<p>当使用基本数据类型声明变量时，C会在称为堆栈的内存区域中自动为变量分配空间。</p>
<p>例如，声明一个int变量通常会分配4个字节。我们可以通过使用sizeof运算符知道这一点：</p>
<pre><code class="language-c">int x;
printf(&quot;%d&quot;, sizeof(x)); /* output: 4 */
</code></pre>
<p>再举一个例子，给具有指定大小的数组分配连续的内存块，每个块的大小为一个元素的大小：</p>
<pre><code class="language-c">int arr[10];
printf(&quot;%d&quot;, sizeof(arr)); /* output: 40 */
</code></pre>
<p>只要你的程序显式声明基本数据类型或数组大小，就会自动管理内存。</p>
<p>但是，如果你希望实现一个程序，在该程序中直到运行时才确定数组的大小。</p>
<p>**动态内存分配是根据需要分配和释放内存的过程。**现在，你可以在运行时提示输入数组元素的数量，然后创建具有多元素的数组。</p>
<p>动态内存是使用指针管理的，这些指针指向在称为堆的区域中新分配的内存块。</p>
<blockquote>
<p>除了使用堆栈进行自动内存管理和使用堆进行动态内存分配外，主内存中还存在静态管理的数据，这些数据在程序的生命期内一直存在。</p>
</blockquote>
<h2 id="内存管理函数">内存管理函数</h2>
<p>stdlib.h库包含内存管理函数。</p>
<p>程序顶部的语句#include &lt;stdlib.h&gt;</p>
<p>使你可以调用以下函数：</p>
<p>malloc(bytes) 返回一个指向连续内存块的指针，该内存块的大小为bytes。</p>
<p>calloc(num_items, item_size) 返回一个指向具有 num_items 项的连续内存块的指针，每个项的大小为item_size字节。</p>
<p>通常用于数组，结构和其他派生数据类型。分配的内存被初始化为0。</p>
<p>realloc(ptr, bytes) 将ptr指向的内存大小调整为字节大小。新分配的内存未初始化。</p>
<p><strong>free(ptr) 释放ptr指向的内存块</strong>。</p>
<blockquote>
<p>当你不再需要分配的内存块时，请使用函数 free() 释放使该块内存可再次分配。</p>
</blockquote>
<h2 id="malloc函数">malloc函数</h2>
<p><strong>malloc() 函数在内存中分配指定数量的连续字节。</strong></p>
<ul>
<li>分配的内存是<strong>连续</strong>的，可以视为数组。代替使用方括号[]来引用元素，而是使用指针算术遍历数组。</li>
<li>建议使用+来引用数组元素。使用++或+=更改指针存储的地址。</li>
<li>如果分配不成功，则返回NULL。因此，你应该包含用于检查NULL指针的代码。</li>
</ul>
<blockquote>
<p>一个简单的二维数组需要 <strong>(rows*columns)*sizeof(datatype)</strong> 字节的内存。</p>
</blockquote>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

int *ptr;
/* a block of 10 ints */
ptr = malloc(10 * sizeof(*ptr));

if (ptr != NULL) {
  *(ptr + 2) = 50;  /* 将 50 赋值给第3个int */
}
</code></pre>
<p>malloc 返回指向已分配内存的指针。</p>
<p>注意，将 sizeof 应用于 *ptr 而不是 int，如果稍后将 *ptr 声明更改为其他数据类型，则使代码更加健壮。</p>
<figure data-type="image" tabindex="5"><img src="https://i0.hdslb.com/bfs/album/00ee4a84550b8f11958ee7279a3b137647fdbe38.png" alt="" loading="lazy"></figure>
<h2 id="free函数">free函数</h2>
<p>free() 函数是一个内存管理函数，被称为释放内存。通过释放内存，你可以在以后的程序中使用更多内存。</p>
<p>例如:</p>
<pre><code class="language-c">int* ptr = malloc(10 * sizeof(*ptr));
if (ptr != NULL)
  *(ptr + 2) = 50;  /* assign 50 to third int */
printf(&quot;%d\n&quot;, *(ptr + 2));

free(ptr);
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://i0.hdslb.com/bfs/album/b53ecb784395ea99c4b88b3ceaf1e72d3cb0c180.png" alt="" loading="lazy"></figure>
<h2 id="calloc函数">calloc函数</h2>
<p><strong>calloc() 函数根据特定项（例如结构）的大小分配内存。</strong></p>
<p>下面的程序使用calloc为结构分配内存，并使用malloc为结构中的字符串分配内存：</p>
<pre><code class="language-c">typedef struct {
  int num;
  char *info;
} record;

record *recs;
int num_recs = 2;
int k;
char str[ ] = &quot;This is information&quot;;

recs = calloc(num_recs, sizeof(record));
if (recs != NULL) {
  for (k = 0; k &lt; num_recs; k++) {
    (recs+k)-&gt;num = k;
    (recs+k)-&gt;info = malloc(sizeof(str));
    strcpy((recs+k)-&gt;info, str);
  }
} 
</code></pre>
<p>**calloc 在连续的内存块内为结构元素数组分配内存。**你可以使用指针算法从一种结构导航到另一种结构。</p>
<p>在为结构分配空间之后，必须为结构内的字符串分配内存。为信息成员使用指针允许存储任何长度的字符串。</p>
<p><strong>动态分配的结构是链接列表和二叉树以及其他数据结构的基础。</strong></p>
<h2 id="realloc-函数">realloc 函数</h2>
<p>*<em>realloc(void <em>ptr, size_t size)：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。</em></em></p>
<p>如果将分配的内存减少，realloc仅仅是改变索引的信息。</p>
<p>如果是将分配的内存扩大，则有以下情况：</p>
<ol>
<li>如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。</li>
<li>如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据块释放掉，返回新的内存块位置。</li>
<li>如果申请失败，将返回NULL，此时，原来的指针仍然有效。</li>
</ol>
<p>例如:</p>
<pre><code class="language-c">int *ptr;
ptr = malloc(10 * sizeof(*ptr));  
if (ptr != NULL) {
  *(ptr + 2) = 50;  /* assign 50 to third int */
}
ptr = realloc(ptr, 100 * sizeof(*ptr)); 
*(ptr + 30) = 75; 
</code></pre>
<p>realloc将原始内容保留在内存中，并扩展该块以允许更多存储。</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
	int* arr = malloc(sizeof(int));
	*arr = 13;
	arr = realloc(arr, 2 * sizeof(int));
	*(arr + 1) = *arr;
	printf(&quot;%d&quot;, *(arr + 1));
}

</code></pre>
<p>结果：</p>
<pre><code class="language-c">13
</code></pre>
<h2 id="为字符串分配内存">为字符串分配内存</h2>
<p><strong>在为字符串指针分配内存时，你可能需要使用字符串长度而不是sizeof运算符来计算字节。</strong></p>
<p>例如:</p>
<pre><code class="language-c">char str20[20];
char *str = NULL;

strcpy(str20, &quot;12345&quot;);
str = malloc(strlen(str20) + 1); 
strcpy(str, str20);
printf(&quot;%s&quot;, str); 
</code></pre>
<p>这种方法可以更好地管理内存，因为你分配的空间不会超出指针所需的空间。</p>
<p>当使用strlen确定字符串所需的字节数时，请确保为NULL字符'\0'添加一个额外的字节。</p>
<p>char 始终是一个字节，因此无需将内存需求乘以 sizeof(char)。</p>
<figure data-type="image" tabindex="7"><img src="https://i0.hdslb.com/bfs/album/ddfc845ec4358b815ffa26943816ee04be9a8c61.png" alt="" loading="lazy"></figure>
<h2 id="动态数组">动态数组</h2>
<p>许多算法实现了动态数组，因为这允许元素的数量根据需要增加。</p>
<p>由于不会一次分配所有元素，因此动态数组通常使用一种结构来跟踪当前数组的大小，当前容量以及指向元素的指针，如以下程序所示。</p>
<pre><code class="language-c">typedef struct {
  int *elements;
  int size;
  int cap;
} dyn_array;

dyn_array arr;

/* initialize array */
arr.size = 0;
arr.elements = calloc(1, sizeof(*arr.elements) );
arr.cap = 1;  /* room for 1 element */ 
</code></pre>
<p>要扩展更多元素：</p>
<pre><code class="language-c">arr.elements = realloc(arr.elements, (5 + arr.cap) * sizeof(*arr.elements));
if (arr.elements != NULL)
  arr.cap += 5; /* increase capacity */ 
</code></pre>
<p>向数组添加元素会增加其大小：</p>
<pre><code class="language-c">if (arr.size &lt; arr.cap) {
  arr.elements[arr.size] = 50;
  arr.size++;
} else {
  printf(&quot;Need to expand the array.&quot;);
}
</code></pre>
<p>以上程序做了简化。</p>
<p>为了正确实现动态数组，应该将子任务分解为 init_array()，increment_array()，add_element() 和 display_array()之类的函数。</p>
<p>错误检查也被跳过，使演示简短。</p>
<h2 id="访问文件">访问文件</h2>
<p><strong>在C语言中，操作文件之前必须先打开文件；所谓“打开文件”，就是让程序和文件建立连接的过程。</strong></p>
<p>打开文件之后，程序可以得到文件的相关信息，例如大小、类型、权限、创建者、更新时间等。在后续读写文件的过程中，程序还可以记录当前读写到了哪个位置，下次可以在此基础上继续操作。</p>
<blockquote>
<p>标准输入文件 stdin（表示键盘）、标准输出文件 stdout（表示显示器）、标准错误文件 stderr（表示显示器）是由系统打开的，可直接使用。</p>
</blockquote>
<p>使用 &lt;stdio.h&gt; 头文件中的 fopen() 函数即可打开文件，它的用法为：</p>
<p>FILE *fopen(char *filename, char *mode);</p>
<p><code>filename</code>为文件名（包括文件路径），<code>mode</code>为打开方式，它们都是字符串。</p>
<h3 id="fopen-函数的返回值">fopen() 函数的返回值</h3>
<p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回。</p>
<p>FILE 是 &lt;stdio.h&gt; 头文件中的一个结构体，它专门用来保存文件信息。我们不用关心 FILE 的具体结构，只需要知道它的用法就行。</p>
<p>如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如：</p>
<pre><code class="language-c">FILE *fp = fopen(&quot;demo.txt&quot;, &quot;r&quot;);
</code></pre>
<p>表示以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。</p>
<p>再来看一个例子：</p>
<pre><code class="language-c">FILE *fp = fopen(&quot;D:\\demo.txt&quot;,&quot;rb+&quot;);
</code></pre>
<p>表示以二进制方式打开 D 盘下的 demo.txt 文件，允许读和写。</p>
<h3 id="判断文件是否打开成功">判断文件是否打开成功</h3>
<p>**打开文件出错时，fopen() 将返回一个空指针，也就是 NULL，**我们可以利用这一点来判断文件是否打开成功，请看下面的代码：</p>
<pre><code class="language-c">FILE *fp;
if( (fp=fopen(&quot;D:\\demo.txt&quot;,&quot;rb&quot;) == NULL ){
    printf(&quot;Fail to open file!\n&quot;);
    exit(0);  //退出程序（结束程序）
}
</code></pre>
<p>我们通过判断 fopen() 的返回值是否和 NULL 相等来判断是否打开失败：如果 fopen() 的返回值为 NULL，那么 fp 的值也为 NULL，此时 if 的判断条件成立，表示文件打开失败。</p>
<p>以上代码是文件操作的规范写法，读者在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。</p>
<h2 id="fopen-函数的打开方式">fopen() 函数的打开方式</h2>
<p>不同的操作需要不同的文件权限。例如，只想读取文件中的数据的话，“只读”权限就够了；既想读取又想写入数据的话，“读写”权限就是必须的了。另外，文件也有不同的类型，按照数据的存储方式可以分为二进制文件和文本文件，它们的操作细节是不同的。在调用 fopen() 函数时，这些信息都必须提供，称为“文件打开方式”。最基本的文件打开方式有以下几种：</p>
<figure data-type="image" tabindex="8"><img src="https://atts.w3cschool.cn/attachments/day_191211/201912111605391819.png" alt="img" loading="lazy"></figure>
<p>例子:</p>
<pre><code>#include &lt;stdio.h&gt;

int main() {  
  FILE *fptr;
  
  fptr = fopen(&quot;myfile.txt&quot;, &quot;w&quot;);
  if (fptr == NULL) {
    printf(&quot;Error opening file.&quot;);
    return -1;
  }
  fclose(fptr);
  return 0;
} 
</code></pre>
<p>当使用字符串文字来指定文件名时，转义序列\表示单个反斜杠。</p>
<p>在此程序中，如果打开文件时出错，则将 -1 错误代码返回到系统。</p>
<blockquote>
<p>在此程序中，如果打开文件时出错，则将-1错误代码返回到系统。错误处理将在以后介绍。</p>
</blockquote>
<h2 id="从文件读取">从文件读取</h2>
<p>stdio.h库还包括用于从打开的文件读取的函数。</p>
<p>一个文件可以一次读取一个字符，也可以将整个字符串读入字符缓冲区，该缓冲区通常是用于临时存储的char数组。</p>
<ul>
<li>
<p><strong>getc(fp)</strong> 返回fp指向的文件中的下一个字符。如果已到达文件末尾，则返回EOF。</p>
</li>
<li>
<p><strong>fgets(buff, n, fp)</strong> fgets函数功能为从指定的流中读取数据，每次读取一行。</p>
</li>
</ul>
<p>其原型为：char *fgets(char *str, int n, FILE *stream);从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。</p>
<p>当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p>
<ul>
<li><strong>fscanf(fp, conversion_specifiers, vars)</strong> 从fp指向的文件中读取字符，并使用conversion_specifiers将输入分配给变量指针vars列表。与scanf一样，遇到空格或换行符时，fscanf会停止读取字符串。</li>
</ul>
<p>例如：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {  
  FILE *fptr;
  int c, stock;
  char buffer[200], item[10];
  float price;

  /* myfile.txt: Inventory\n100 Widget 0.29\nEnd of List */

  fptr = fopen(&quot;myfile.txt&quot;, &quot;r&quot;);

  fgets(buffer, 20, fptr);    /* read a line */
  printf(&quot;%s\n&quot;, buffer);

  fscanf(fptr, &quot;%d%s%f&quot;, &amp;stock, item, &amp;price); /* read data */
  printf(&quot;%d  %s  %4.2f\n&quot;, stock, item, price);

  while ((c = getc(fptr)) != EOF) /* read the rest of the file */
    printf(&quot;%c&quot;, c);

  fclose(fptr);
  return 0;
} 
</code></pre>
<p>gets() 函数读取直到换行符。 fscanf() 根据转换说明符读取数据。</p>
<p>然后 while 循环一次读取一个字符，直到文件结束。</p>
<h2 id="写入文件">写入文件</h2>
<p>stdio.h库还包括用于写入文件的函数。写入文件时，必须显式添加换行符'\ n'。</p>
<ul>
<li>
<p><strong>fputc(char, fp)</strong> 将字符char写入fp指向的文件。</p>
</li>
<li>
<p><strong>fputs(str, fp)</strong> 将字符串str写入fp指向的文件。</p>
</li>
<li>
<p><strong>fprintf(fp, str, vars)</strong> 将字符串str打印到fp指向的文件。 str可以选择包括格式说明符和变量vars列表。</p>
</li>
</ul>
<p>例如:</p>
<pre><code>FILE *fptr;
char filename[50];
printf(&quot;Enter the filename of the file to create: &quot;);
gets(filename);
fptr = fopen(filename, &quot;w&quot;);

/* 写文件 */
fprintf(fptr, &quot;Inventory\n&quot;);
fprintf(fptr, &quot;%d %s %f\n&quot;, 100, &quot;Widget&quot;, 0.29);
fputs(&quot;End of List&quot;, fptr); 
</code></pre>
<blockquote>
<p>“ w”参数为fopen函数定义“写入模式”。</p>
</blockquote>
<h2 id="二进制文件io_1">二进制文件I/O_1</h2>
<p>当你具有数组或结构时，仅将字符和字符串写入文件可能会变得乏味。</p>
<p>要将整个内存块写入文件，有以下二进制函数：</p>
<figure data-type="image" tabindex="9"><img src="https://atts.w3cschool.cn/attachments/image/20191211/1576054957788154.png" alt="img" loading="lazy"></figure>
<p><strong>fwrite(ptr, item_size, num_items, fp)</strong> 将num_items个item_size大小的项目从指针ptr写入文件指针fp所指向的文件。</p>
<p><strong>fread(ptr, item_size, num_items, fp)</strong> 从文件指针fp所指向的文件中读取item_size大小的num_items项到ptr所指向的内存中。</p>
<p><strong>fclose(fp)</strong> 关闭以文件fp打开的文件，如果关闭成功，则返回0。如果关闭错误，则返回EOF。</p>
<blockquote>
<p>feof(fp) 当到达文件流的末尾时返回0。</p>
</blockquote>
<h2 id="二进制文件-io_2">二进制文件 I/O_2</h2>
<p>该程序将整数数组写入文件，但是将结构数组写入文件同样容易。</p>
<p>以下程序演示了如何读写二进制文件：</p>
<pre><code>FILE *fptr;
int arr[10];
int x[10];
int k;

/* 初始化数组的值 */
for (k = 0; k &lt; 10; k++)
  arr[k] = k;

/* 将数组数据写入文件 */
fptr = fopen(&quot;datafile.bin&quot;, &quot;wb&quot;);
fwrite(arr, sizeof(arr[0]), sizeof(arr)/sizeof(arr[0]), fptr);
fclose(fptr);

/* 从文件读取数组数据 */
fptr = fopen(&quot;datafile.bin&quot;, &quot;rb&quot;);
fread(x, sizeof(arr[0]), sizeof(arr)/sizeof(arr[0]), fptr);
fclose(fptr);

/* 打印数组 */
for (k = 0; k &lt; 10; k++)
  printf(&quot;%d&quot;, x[k]); 
</code></pre>
<p>该程序将整数数组写入文件，将结构数组写入文件同样容易。</p>
<p>注意，项目大小和项目数是通过使用元素的大小和整个变量的大小来确定的。</p>
<p>单独的文件扩展名并不能确定文件中数据的格式，但是它们对于指示期望的数据类型很有用。</p>
<p>例如，.txt扩展名表示文本文件，.bin表示二进制数据，.csv表示逗号分隔的值，.dat表示数据文件。</p>
<figure data-type="image" tabindex="10"><img src="https://i0.hdslb.com/bfs/album/2b4e12935edd84c6c6abb3a4d4779a12a7feb5eb.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://i0.hdslb.com/bfs/album/d3383d492043f984c9bf22c21de9978fbc812785.png" alt="" loading="lazy"></figure>
<h2 id="控制文件指针">控制文件指针</h2>
<p>stdio.h中有一些函数可以控制二进制文件中文件指针的位置：</p>
<p>ftell(fp) 返回一个long int值，该值对应于fp文件指针位置（从文件开头开始的字节数）。</p>
<p>fseek(fp, num_bytes, from_pos) 将 fp 文件指针的位置相对于from_pos位置移动num_bytes个字节，</p>
<p>该位置可以是以下常量之一：</p>
<p>-SEEK_SET 文件的开始</p>
<p>-SEEK_CUR 当前位置</p>
<p>-SEEK_END 文件结尾</p>
<p>以下程序从结构文件中读取一条记录：</p>
<pre><code class="language-c">typedef struct {
  int id;
  char name[20];
} item;

int main() { 
  FILE *fptr;
  item first, second, secondf;

  /* 创建记录 */
  first.id = 10276;
  strcpy(first.name, &quot;Widget&quot;);
  second.id = 11786;
  strcpy(second.name, &quot;Gadget&quot;);
  
  /* 将记录写入文件 */
  fptr = fopen(&quot;info.dat&quot;, &quot;wb&quot;);
  fwrite(&amp;first, 1, sizeof(first), fptr);
  fwrite(&amp;second, 1, sizeof(second), fptr);
  fclose(fptr); 

  /* 文件包含2条类型的记录 */
  fptr = fopen(&quot;info.dat&quot;, &quot;rb&quot;);

  /* 查找第二纪录 */
  fseek(fptr, 1*sizeof(item), SEEK_SET);
  fread(&amp;secondf, 1, sizeof(item), fptr);
  printf(&quot;%d  %s\n&quot;, secondf.id, secondf.name);
  fclose(fptr);
  return 0;
} 
</code></pre>
<p>该程序将两个项目记录写入文件。为了只读取第二条记录，fseek() 将文件指针从文件开头移到 1 * sizeof(item) 个字节。</p>
<p>例如，如果你想将指针移动到第四条记录，则从文件开头（SEEK_SET）查找 3 * sizeof(item)。</p>
<h2 id="异常处理">异常处理</h2>
<p><strong>良好编程习惯的核心是使用错误处理技术。如果你忘记异常处理，即使是最扎实的编码技巧也可能无法阻止程序崩溃。</strong></p>
<p><strong>任何导致你的程序停止正常执行的情况都是异常。</strong></p>
<p><strong>异常处理（也称为错误处理）是一种处理运行时错误的方法。</strong></p>
<p>C不明确支持异常处理，但是有一些方法可以管理错误：</p>
<p>-首先编写代码以防止错误。你无法控制用户输入，但是可以检查以确保用户输入了有效输入。</p>
<p>执行除法时，请采取额外的步骤以确保不会发生被0除的情况。</p>
<p>-使用exit语句正常结束程序执行。你可能无法控制文件是否可读取，但是不必让问题使程序崩溃。</p>
<blockquote>
<p>使用 errno，perror() 和 strerror() 通过错误代码识别错误。</p>
</blockquote>
<h2 id="退出命令">退出命令</h2>
<p>exit命令立即停止程序的执行，并将退出代码发送回调用过程。</p>
<p>例如，如果一个程序被另一个程序调用，则调用程序可能需要知道退出状态。</p>
<p>使用exit避免程序崩溃是一个好习惯，因为它会关闭所有打开的文件连接和进程。</p>
<p>你可以通过exit语句返回任何值，但是0表示成功，-1表示失败。</p>
<p>预定义的 stdlib.h 宏 EXIT_SUCCESS 和 EXIT_FAILURE 也很常用。</p>
<p>例如:</p>
<pre><code class="language-c">int x = 10;
int y = 0;

if (y != 0)
  printf(&quot;x / y = %d&quot;, x/y);
else {
  printf(&quot;Divisor is 0. Program exiting.&quot;);
  exit(EXIT_FAILURE);
} 
</code></pre>
<h2 id="使用errno">使用errno</h2>
<p>一些库函数（例如 fopen()）在未按预期执行时会设置错误代码。</p>
<p>错误代码在名为errno的全局变量中设置，该变量在errno.h头文件中定义。</p>
<p>使用errno时，应在调用库函数之前将其设置为0。</p>
<p>要输出存储在errno中的错误代码，可以使用fprintf打印到strerr文件流，将标准错误输出到屏幕。</p>
<p>使用strerr是一个惯例问题，也是一种好的编程习惯。</p>
<p>你可以通过其他方式输出errno，但如果仅将strerr用于错误消息，则可以更轻松地跟踪异常处理。</p>
<p>例如:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// #include &lt;errno.h&gt;

extern int errno;

int main() {
  FILE *fptr;
  int c;

  errno = 0;
  fptr = fopen(&quot;c:\\nonexistantfile.txt&quot;, &quot;r&quot;);
  if (fptr == NULL) {
    fprintf(stderr, &quot;Error opening file. Error code: %d\n&quot;, errno);
    exit(EXIT_FAILURE);
  }

  fclose(fptr);
  return 0;
} 
</code></pre>
<h1 id="预处理指令">预处理指令</h1>
<h2 id="预定义的宏定义">预定义的宏定义</h2>
<p>除了定义自己的宏之外，还有一些标准的预定义宏在C程序中始终可用，而无需使用#define指令：</p>
<p>_<em>DATE</em>_ 当前日期，以字符串形式，格式为 Mm dd yyyy</p>
<p>_<em>TIME</em>_ 当前时间，以字符串形式，格式为 hh：mm：ss</p>
<p>_<em>FILE</em>_ 当前文件名作为字符串</p>
<p>_<em>LINE</em>_ 当前行号 为int值</p>
<p>_<em>STDC</em>_ 1</p>
<p>例如:</p>
<pre><code class="language-c">char curr_time[10];
char curr_date[12];
int std_c;

strcpy(curr_time, __TIME__);
strcpy(curr_date, __DATE__);
printf(&quot;%s %s\n&quot;, curr_time, curr_date);
printf(&quot;This is line %d\n&quot;, __LINE__);    
std_c = __STDC__;
printf(&quot;STDC is %d&quot;, std_c); 
</code></pre>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98">使用内存</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88">什么是指针？</a></li>
<li><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88">表达式中的指针</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84">指针和数组</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%9C%B0%E5%9D%80%E7%AE%97%E6%B3%95">更多地址算法</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0">指针与函数</a></li>
<li><a href="#%E5%85%B7%E6%9C%89%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0">具有数组参数的函数</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0">返回数组的函数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5">字符串输入</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA">字符串输出</a></li>
<li><a href="#sprintf-%E5%92%8C-sscanf-%E5%87%BD%E6%95%B0">sprintf 和 sscanf 函数</a></li>
<li><a href="#stringh%E5%BA%93%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0">string.h库（字符串函数）</a></li>
<li><a href="#%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97">将字符串转换为数字</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84">字符串数组</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">函数指针数组</a></li>
<li><a href="#%E7%A9%BA%E6%8C%87%E9%92%88">空指针</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0">使用空指针的函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">函数指针作为参数</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">结构体变量的定义</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F">声明结构体变量</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E7%94%A8">结构体变量的引用</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8typedef">使用typedef</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%93%E6%9E%84">结构与结构</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88">指向结构的指针</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">结构作为函数参数</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84">结构数组</a></li>
<li><a href="#%E5%85%B1%E7%94%A8%E4%BD%93">共用体</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E5%85%B1%E7%94%A8%E4%BD%93%E6%88%90%E5%91%98">访问共用体成员</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%85%B1%E7%94%A8%E4%BD%93">结构体内共用体</a></li>
<li><a href="#%E5%85%B1%E7%94%A8%E4%BD%93%E6%8C%87%E9%92%88">共用体指针</a></li>
<li><a href="#%E5%85%B1%E7%94%A8%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">共用体作为函数参数</a></li>
<li><a href="#%E5%85%B1%E7%94%A8%E4%BD%93%E6%95%B0%E7%BB%84">共用体数组</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0">内存管理函数</a></li>
<li><a href="#malloc%E5%87%BD%E6%95%B0">malloc函数</a></li>
<li><a href="#free%E5%87%BD%E6%95%B0">free函数</a></li>
<li><a href="#calloc%E5%87%BD%E6%95%B0">calloc函数</a></li>
<li><a href="#realloc-%E5%87%BD%E6%95%B0">realloc 函数</a></li>
<li><a href="#%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98">为字符串分配内存</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">动态数组</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6">访问文件</a>
<ul>
<li><a href="#fopen-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">fopen() 函数的返回值</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80%E6%88%90%E5%8A%9F">判断文件是否打开成功</a></li>
</ul>
</li>
<li><a href="#fopen-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F">fopen() 函数的打开方式</a></li>
<li><a href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">从文件读取</a></li>
<li><a href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6">写入文件</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6io_1">二进制文件I/O_1</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-io_2">二进制文件 I/O_2</a></li>
<li><a href="#%E6%8E%A7%E5%88%B6%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88">控制文件指针</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li>
<li><a href="#%E9%80%80%E5%87%BA%E5%91%BD%E4%BB%A4">退出命令</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8errno">使用errno</a></li>
</ul>
</li>
<li><a href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4">预处理指令</a>
<ul>
<li><a href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%8F%E5%AE%9A%E4%B9%89">预定义的宏定义</a></li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://KA-ASLant.GitHub.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://KA-ASLant.GitHub.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
</body>

</html>