import{_ as o,c as k,I as a,j as s,w as n,a as i,au as l,D as e,o as d}from"./chunks/framework.RMxno62p.js";const c="/assets/x-oss-process_image.DGoyYNmx.png",g="/assets/x-oss-process_image.1.WoBJzhBR.png",_="/assets/x-oss-process_image.2.DKphn0ka.png",f="/assets/x-oss-process_image.3.FZRtNqGx.png",A="/assets/cef384a6da3b477fb249d8e4f55bec20.Cajp1NxB.png",D="/assets/x-oss-process_image.4.D_xwpXna.png",C="/assets/81b2145a034945779845f5ce2653aa30.CEAiky4Y.png",F="/assets/x-oss-process_image.5.C_4AmoMX.png",y="/assets/b1575374f7bf49b083c577565ee334e6.yiKIGay_.png",B="/assets/302189a742104f01aad8fc23c70723fd.DWPyp3f4.png",u="/assets/x-oss-process_image.6.EPrg-1C4.png",O="/assets/x-oss-process_image.7.CpJ8zAby.png",m="/assets/x-oss-process_image.8.B782OMNN.png",E="/assets/91a4cc1e14aa455d9a55ebf883a7b52b.Bq61aLk5.png",ss=JSON.parse('{"title":"OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法","description":"","frontmatter":{"tags":["运维","计算机/网络","开源/软件/OpenWRT","开源/软件/OpenWRT/Lede","操作系统/iOS","操作系统/iPadOS","计算机/网络/路由/OpenWRT","操作系统/iOS/通知","命令行/iptables","Archive","Archive/CSDN"]},"headers":[],"relativePath":"笔记/📃 Archives/📖 文章/CSDN/Chocola-/OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法.md","filePath":"笔记/📃 Archives/📖 文章/CSDN/Chocola-/OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法.md"}'),w={name:"笔记/📃 Archives/📖 文章/CSDN/Chocola-/OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法.md"},b=s("h1",{id:"openwrt-开启-softwarehardware-flow-offloading-后-ios-通知推送延迟问题的溯源及一点解决办法",tabindex:"-1"},[i("OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法 "),s("a",{class:"header-anchor",href:"#openwrt-开启-softwarehardware-flow-offloading-后-ios-通知推送延迟问题的溯源及一点解决办法","aria-label":'Permalink to "OpenWRT 开启 SoftwareHardware Flow Offloading 后 iOS 通知推送延迟问题的溯源及一点解决办法"'},"​")],-1),T=s("hr",null,null,-1),P=s("h5",{id:"archive-信息",tabindex:"-1"},[i("Archive 信息 "),s("a",{class:"header-anchor",href:"#archive-信息","aria-label":'Permalink to "Archive 信息"'},"​")],-1),W={tabindex:"0"},L=s("thead",null,[s("tr",null,[s("th",null,"Archive 自"),s("th",null,"Archive 创建于"),s("th",null,"分类"),s("th",null,"原始作者"),s("th",null,"原始地址"),s("th",null,"原始资源创建时间"),s("th",null,"原始资源更新时间")])],-1),S=s("td",null,"CSDN",-1),v=s("td",null,"2022-10-29 18:06",-1),N=s("td",null,"文章",-1),I=s("td",null,"2022-03-11 11:32:40",-1),R=s("td",null,"2022-03-11 11:32:40",-1),x={id:"openwrt开启software-hardware-flow-offloading后ios通知推送延迟问题的溯源及一点解决办法",tabindex:"-1"},U=s("a",{class:"header-anchor",href:"#openwrt开启software-hardware-flow-offloading后ios通知推送延迟问题的溯源及一点解决办法","aria-label":'Permalink to "[OpenWrt](https://so.csdn.net/so/search?q=OpenWrt&spm=1001.2101.3001.7020)开启Software/Hardware Flow Offloading后iOS通知推送延迟问题的溯源及一点解决办法"'},"​",-1),H=s("p",null,[s("img",{src:c,alt:""})],-1),M=s("p",null,"图1 MT7621官方数据参数",-1),K=l("",38),q=s("blockquote",null,[s("p",null,"Then, after 2 minutes, the conntrack entry disappears. I would expect it to disappear after ~2 hours of inactivity, not 2 minutes."),s("p",null,"Can anyone else confirm this behavior? Is it a bug?"),s("p",null,"Why doesn’t the count-down use the nf_conntrack_tcp_timeout_established value when it exits the [OFFLOAD] status? Where can I change the timeout that is used after the connection exits the [OFFLOAD] status?")],-1),V=s("p",null,"下面有人回答了这个问题：",-1),G=l("",16);function j(Y,z,X,$,J,Z){const p=e("NolebasePageProperties"),t=e("VPNolebaseInlineLinkPreview"),h=e("NolebaseGitContributors"),r=e("NolebaseGitChangelog");return d(),k("div",null,[b,a(p),T,P,s("table",W,[L,s("tbody",null,[s("tr",null,[S,v,N,s("td",null,[a(t,{href:"https://blog.csdn.net/weixin_43744534",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("Chocola-")]),_:1})]),s("td",null,[a(t,{href:"https://blog.csdn.net/weixin_43744534/article/details/123418289",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("链接")]),_:1})]),I,R])])]),s("h3",x,[a(t,{href:"https://so.csdn.net/so/search?q=OpenWrt&spm=1001.2101.3001.7020",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("OpenWrt")]),_:1}),i("开启Software/Hardware Flow Offloading后iOS通知推送延迟问题的溯源及一点解决办法 "),U]),s("p",null,[i("实际上这个问题是我在将"),a(t,{href:"https://so.csdn.net/so/search?q=%E8%B7%AF%E7%94%B1%E5%99%A8&spm=1001.2101.3001.7020",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("路由器")]),_:1}),i("刷成OpenWrt后偶然发现的。本来自使用的路由器是AX3 Pro，但是使用一段时间后发现这个路由器对IPv6的分配策略上有着不小的问题：本地运营商下发了/60的前缀后，此路由器并不会自动将此段地址切割以供二级路由使用，导致二级路由只能分配到/64的IPv6地址，无法继续下发地址，虽然在二级路由上可以使用NAT技术使下挂设备使用IPv6网络，但是这样显然违背了IPv6设计的初衷；其次，AX3 Pro默认将IPv6防火墙完全打开，同时无法在管理页面将此防火墙关闭，导致无法从公网访问到路由器后面的IPv6设备，这也明显阻碍了从外界管理内网设备的需求。所以，只能无奈舍弃这款路由器而选择可以刷入OpenWrt的路由器（OpenWrt对于IPv6及相关设置的支持良好），选择了搭载MT7621+MT7615的路由器解锁SSH权限并刷入了OpenWrt系统。")]),H,M,s("p",null,[i("刷入系统几天后，偶然在一次聊天中发现iOS的消息通知推送有了延迟，通知框最迟的时候显示的是将近十分钟前的消息。于是用另一台设备发送测试消息，发现只要设备空闲超过两分钟，iOS的通知消息便有了明显的延迟。起初怀疑是官方的OpenWrt版本使用的都是开源驱动，对第三方设备的支持并不那么良好，于是自己拉取源码，修改编译选项将开源驱动换为MTK官方的闭源驱动编译出固件，再次刷入后发现问题仍然存在，但是后来换成完全基于MTK官方驱动且可以完全调用MT7621的硬件加速功能的Padavan系统后就不再存在消息延迟的问题。这个问题很令人感到困惑，本以为是驱动造成的问题，但是同样使用了闭源驱动，两个系统却有不一样的表现，只能是OpenWrt可能在某些关于网络的实现上有问题，但具体是哪里的问题，实在是不太好发现。于是在各个有关网络的论坛内搜索有没有类似的情况出现，终于在这个帖子内找到了遇到过类似问题的人： "),a(t,{href:"https://v2ex.com/t/804005",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("iPhone 推送通知延迟，这种情况出现在只连接 WIFI 的情况下。")]),_:1}),i("并且下面有网友给出了一种可能的解决办法。")]),K,s("p",null,[i("可以看到已建立的连接，established状态的连接超时时间为7440s，明显要大于几分钟的时间，这是什么原因呢？在OpenWrt官方论坛中，通过搜索conntrack与timeout关键字，找到了一篇名为《Software "),a(t,{href:"https://so.csdn.net/so/search?q=flow&spm=1001.2101.3001.7020",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("flow")]),_:1}),i(" offloading and conntrack timeouts》的提问帖："),a(t,{href:"https://forum.openwrt.org/t/software-flow-offloading-and-conntrack-timeouts/74588",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("Software flow offloading and conntrack timeouts")]),_:1}),i("，他也遇到了类似的超时问题，并发出了提问：")]),q,V,s("blockquote",null,[s("p",null,[i("Q:Can anyone else confirm this behavior? A:Yes, flow tables evict inactive flows after 30 seconds, conntrack will then pickup the connection if there are any traffic in 120 seconds. Q:Is it a bug? A:This is quite unfortunate, but seems it is indeed deliberate, and not configurable: "),a(t,{href:"https://patchwork.ozlabs.org/project/netdev/patch/20180720130906.27687-3-pablo@netfilter.org/",target:"_blank",rel:"noreferrer"},{default:n(()=>[i("[02/38] netfilter: flowtables: use fixed renew timeout on teardown")]),_:1})])]),G,a(h),a(r)])}const is=o(w,[["render",j]]);export{ss as __pageData,is as default};
