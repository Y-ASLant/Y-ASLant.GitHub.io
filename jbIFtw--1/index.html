<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Linux从入门到入坟_01 - Note</title>
<link rel="shortcut icon" href="https://KA-ASLant.GitHub.io/favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://KA-ASLant.GitHub.io/media/css/tailwind.css">
<link rel="stylesheet" href="https://KA-ASLant.GitHub.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Linux从入门到入坟_01 - Note - Atom Feed" href="https://KA-ASLant.GitHub.io/atom.xml">

<script async custom-element="amp-iframe"
  src="https://cdn.ampproject.org/v0/amp-iframe-0.1.js"></script>
  
    

  <meta name="description" content="      
学习之前，最好你电脑上有安装任意一个Linux操作系统。
除了Arch Linux和 Debian以外，市面上的Linux基本上都是图形化安装界面，很容易安装。
或可以在虚拟机中安装，参考教程：
在Vmware16 Pro中安..." />
  <meta property="og:title" content="Linux从入门到入坟_01 - Note">
  <meta property="og:description" content="      
学习之前，最好你电脑上有安装任意一个Linux操作系统。
除了Arch Linux和 Debian以外，市面上的Linux基本上都是图形化安装界面，很容易安装。
或可以在虚拟机中安装，参考教程：
在Vmware16 Pro中安..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://KA-ASLant.GitHub.io/jbIFtw--1/" />
  <meta property="og:image" content="https://KA-ASLant.GitHub.io/images/avatar.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="Linux从入门到入坟_01 - Note">
  <meta name="twitter:description" content="      
学习之前，最好你电脑上有安装任意一个Linux操作系统。
除了Arch Linux和 Debian以外，市面上的Linux基本上都是图形化安装界面，很容易安装。
或可以在虚拟机中安装，参考教程：
在Vmware16 Pro中安...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://KA-ASLant.GitHub.io/jbIFtw--1/">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://KA-ASLant.GitHub.io/media/css/prism-atom-dark.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://KA-ASLant.GitHub.io" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      Note
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          Linux从入门到入坟_01
        </h1>
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2022年08月04日  Thursday · 10 min read</div>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <meta name="referrer" content="no-referrer" />      
<p><strong>学习之前，最好你电脑上有安装任意一个Linux操作系统。</strong></p>
<p>除了Arch Linux和 Debian以外，市面上的Linux基本上都是图形化安装界面，很容易安装。</p>
<p>或可以在虚拟机中安装，参考教程：</p>
<p><a href="qCGYGw3YK"><code>在Vmware16 Pro中安装Linux</code></a></p>
<h3 id="linux系统分支">Linux系统分支：</h3>
<figure data-type="image" tabindex="1"><img src="https://i0.hdslb.com/bfs/album/69e30788435edaf08280aa755e3c8e0f92330a5d.png" alt="" loading="lazy"></figure>
<p>我们可以在用终端处输入以下命令来查看系统分支：</p>
<pre><code class="language-bash">tree /
</code></pre>
<p>其中，这种命令叫做<strong>bash命令</strong>来自于英文词组“<strong>Bourne shell</strong>”的缩写，其功能是命令<strong>终端</strong>解释器。</p>
<p><strong>bash是绝大多数Linux系统默认的命令终端解释器</strong>，能够处理用户所输入的命令，以及执行指定的Shell脚本文件。</p>
<ul>
<li>提示：Windows下自带的<strong>Power shell</strong>也可以执行部分Linux命令</li>
</ul>
<h4 id="终端的打开">终端的打开</h4>
<p>在图形化Linux界面，在任意目录下右击鼠标，都可以在弹出的选项卡里面选择打开终端。</p>
<p>或着<code>ctrl</code>+<code>alt</code>+<code>t</code>快捷键打开，Linux系统不同，快捷键也不相同！</p>
<h4 id="重要快捷键">重要快捷键</h4>
<p>学习命令行之前，先要掌握几个十分有用、必需掌握的小技巧：</p>
<h5 id="tab"><strong><code>[Tab]</code></strong></h5>
<p>使用<code>Tab</code>键来进行<strong>命令补全</strong>，<code>Tab</code>键一般是在字母<code>Q</code>旁边，<strong>这个技巧给你带来的最大的好处就是当你忘记某个命令的全称时可以只输入它的开头的一部分，然后按下<code>Tab</code>键就可以得到提示或者帮助完成：</strong></p>
<figure data-type="image" tabindex="2"><img src="https://doc.shiyanlou.com/document-uid735639labid2timestamp1531472459081.png" alt="1" loading="lazy"></figure>
<p>当然不止<strong>补全命令</strong>，<strong>补全目录</strong>、<strong>补全命令参数</strong>都是没问题的：</p>
<figure data-type="image" tabindex="3"><img src="https://doc.shiyanlou.com/document-uid735639labid2timestamp1531472445671.png" alt="1" loading="lazy"></figure>
<h5 id="ctrlc"><strong><code>[Ctrl+c]</code></strong></h5>
<p>在Linux命令行中执行了死循环或无意输入了一个不知道的命令，又或者错误地使用了一个命令，导致在终端里出现了你无法预料的情况。</p>
<ul>
<li>例如，<strong>屏幕上只有光标在闪烁却无法继续输入命令，或者不停地输出一大堆你不想要的结果。</strong></li>
<li>使用<code>Ctrl+c</code>键来强行终止当前程序（你可以放心它并不会使终端退出）。</li>
</ul>
<h4 id="历史输入命令">历史输入命令</h4>
<p>使用键盘上的方向上键<code>↑</code>和<code>↓</code> 恢复你之前输入过的命令。</p>
<h4 id="使用通配符">使用通配符</h4>
<p>通配符是一种特殊语句，<strong>主要有星号（*）和问号（?），用来对字符串进行模糊匹配</strong>（比如文件名、参数名）。</p>
<pre><code class="language-bash"># 进入home目录
cd ~
# 显示当前目录下的txt文件
ls *.txt
# 显示当前目录下名字是一个字的txt文件
ls ?.txt
# 显示当前目录下名字是两个字的txt文件
ls ??.txt
</code></pre>
<p><strong>Shell 常用通配符：</strong></p>
<table>
<thead>
<tr>
<th>字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配 0 或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td><code>[^list]</code></td>
<td>匹配 除 list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td><code>[c1-c2]</code></td>
<td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td>
</tr>
<tr>
<td><code>{string1,string2,...}</code></td>
<td>匹配 string1 或 string2 (或更多)其一字符串</td>
</tr>
<tr>
<td><code>{c1..c2}</code></td>
<td>匹配 c1-c2 中全部字符 如{1..10}</td>
</tr>
</tbody>
</table>
<h4 id="在命令行中获取帮助">在命令行中获取帮助</h4>
<p>在 Linux 环境中，如果你遇到困难，可以使用**<code>man</code><strong>命令，它是</strong><code>Manual pages</code><strong>的缩写或者</strong><code>help</code>**命令。</p>
<p>比如你想查看 <code>cd</code> 这个命令本身的使用方式，你可以输入：</p>
<pre><code class="language-bash">man cd
</code></pre>
<p>通常情况下，man 手册里面的内容都是英文的，所以<strong>翻译软件可以说是必备的</strong>。</p>
<p>man 手册的内容很多，涉及了 Linux 使用过程中的方方面面。为了便于查找，man 手册被进行了分册（分区段）处理，在 Research UNIX、BSD、OS X 和 Linux 中，手册通常被分为 8 个区段，安排如下：</p>
<table>
<thead>
<tr>
<th>区段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>一般命令</td>
</tr>
<tr>
<td>2</td>
<td>系统调用</td>
</tr>
<tr>
<td>3</td>
<td>库函数，涵盖了 C 标准函数库</td>
</tr>
<tr>
<td>4</td>
<td>特殊文件（通常是/dev 中的设备）和驱动程序</td>
</tr>
<tr>
<td>5</td>
<td>文件格式和约定</td>
</tr>
<tr>
<td>6</td>
<td>游戏和屏保</td>
</tr>
<tr>
<td>7</td>
<td>杂项</td>
</tr>
<tr>
<td>8</td>
<td>系统管理命令和守护进程</td>
</tr>
</tbody>
</table>
<p>要查看相应区段的内容，就在 man 后面加上相应区段的数字即可，如：</p>
<pre><code class="language-bash">man 1 ls
</code></pre>
<p>会显示第一区段中的<code>ls</code>命令 man 页面。</p>
<pre><code class="language-bash">ls --help
# 也是可以获取此命令的一般用法
</code></pre>
<hr>
<p>在 Linux 系统里， <strong><code>root</code></strong> 账户拥有整个系统至高无上的权限，比如新建和添加用户。</p>
<blockquote>
<p>root 权限，系统权限的一种，与 SYSTEM 权限可以理解成一个概念，但高于 Administrator 权限，root 是 Linux 和 UNIX 系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到 root 权限，这个操作等同于在 Windows 下就是将新建的非法帐户添加到 Administrators 用户组。更比如安卓操作系统中（<strong>安卓系统是基于 Linux 内核</strong>）获得 root 权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的<strong>任何文件</strong>（包括系统文件）执行所有增、删、改、查的操作。</p>
</blockquote>
<pre><code class="language-bash">sudo su
</code></pre>
<p><strong>可以使当前用户暂时获得root权限</strong></p>
<figure data-type="image" tabindex="4"><img src="https://i0.hdslb.com/bfs/album/f037c8f0c39fdfe5cd32fd5902dc61ca850dfdc0.png" alt="" loading="lazy"></figure>
<ul>
<li>在root情况下，你的任何操作都可能带来风险，比如，当你没有root权限时候你执行<code>rm -rf /*</code>虽然也会删除一些系统文件，但是只会删除一点，系统是任然可以正常运行的，如果你获得root权限，再执行该命令，则系统文件将会全部删除，系统将会无法运行，所有资料丢失，这就是常听到的，<code>删库</code>。</li>
</ul>
<p>使用较长格式（详细信息）列出文件：</p>
<pre><code class="language-bash">ls -l
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://i0.hdslb.com/bfs/album/456dd46ac012faac512c2be6ee5d9b779ad7f8ac.png" alt="" loading="lazy"></figure>
<p><img src="https://i0.hdslb.com/bfs/album/ba117e90067942dae77e6abc0656335376c549de.png" alt="" loading="lazy"><br>
<img src="https://i0.hdslb.com/bfs/album/c8ccdd3cefdfb6bbc05171e621d489ee9bae40cb.png" alt="" loading="lazy"></p>
<p>显示除了 <code>.</code>（当前目录）和 <code>..</code>（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 <code>.</code> 开头的文件为隐藏文件）。</p>
<pre><code class="language-bash">ls -a
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://i0.hdslb.com/bfs/album/58304eadceecfd06e3261edcd9000b1e623b2a4c.png" alt="" loading="lazy"></figure>
<p>当然，我们也可以同时使用 <code>-a</code> 和 <code>-l</code> 几个参数：</p>
<pre><code class="language-bash">ls -al
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://i0.hdslb.com/bfs/album/052034ffb42854ef75b9b314c7450b9ca75a93a4.png" alt="" loading="lazy"></figure>
<hr>
<p>在Linux中，<strong>最最重要的就是命令</strong>，这就包含了 2 个过程，输入和输出</p>
<ul>
<li>输入：输入当然就是打开终端，然后按键盘输入，然后按回车，输入格式一般就是这类的</li>
</ul>
<pre><code class="language-bash">#创建一个名为 file 的文件，touch是一个命令
touch file

#进入一个目录，cd是一个命令
cd /etc/

#查看当前所在目录
pwd
</code></pre>
<ul>
<li>输出：输出会返回你想要的结果，比如你要看什么文件，就会返回文件的内容。</li>
<li>如果只是执行，执行失败会告诉你哪里错了，如果执行成功那么会没有输出，因为Linux的哲学就是：<strong>没有结果就是最好的结果。</strong></li>
</ul>
<p>使用 <code>cd</code> 命令可以切换目录，在 Linux 里面使用 <code>.</code> 表示当前目录，<code>..</code> 表示上一级目录(<strong>以 <code>.</code> 开头的文件都是隐藏文件，所以这两个目录必然也是隐藏的，你可以使用 <code>ls -a</code> 命令查看隐藏文件</strong>），<code>-</code> 表示上一次所在目录，<code>~</code> 通常表示当前用户的 <code>home</code> 目录。使用 <code>pwd</code> 命令可以获取当前所在路径（绝对路径）。</p>
<p>进入上一级目录：</p>
<pre><code class="language-bash">cd ..
</code></pre>
<p>进入你的 <code>home</code> 目录：</p>
<pre><code class="language-bash">cd ~
# 或者 cd /home/&lt;你的用户名&gt;
</code></pre>
<p>使用 <code>pwd</code> 获取当前路径：</p>
<pre><code class="language-bash">pwd
</code></pre>
<h4 id="绝对路径">绝对路径</h4>
<p>关于绝对路径，简单地说就是以根&quot; / &quot;目录为起点的完整路径，以你所要到的目录为终点，表现形式如： <code>/usr/local/bin</code>，表示根目录下的 <code>usr</code> 目录中的 <code>local</code> 目录中的 <code>bin</code> 目录。</p>
<h4 id="相对路径">相对路径</h4>
<p>相对路径，也就是相对于你当前的目录的路径，相对路径是以当前目录 <code>.</code> 为起点，以你所要到的目录为终点，</p>
<ul>
<li>表现形式如： <code>usr/local/bin</code> （这里假设你当前目录为根目录）。你可能会看到，表示相对路径实际并没有加上表示当前目录的那个 <code>.</code> ，而是直接以目录名开头，<strong>因为</strong>这个 <code>usr</code> 目录为 <code>/</code> 目录下的子目录，是可以省略这个 <code>.</code> 的（以后会讲到一个类似不能省略的情况）；</li>
<li>如果是当前目录的上一级目录，则需要使用 <code>..</code> ，比如你当前目录为 <code>/home/shiyanlou</code> 目录下，根目录就应该表示为 <code>../../</code> ，表示上一级目录（ <code>home</code> 目录）的上一级目录（ <code>/</code> 目录）。</li>
</ul>
<p>下面我们以Linux的 <code>home</code> 目录为起点，分别以绝对路径和相对路径的方式进入 <code>/usr/local/bin</code> 目录：</p>
<pre><code class="language-bash"># 绝对路径
cd /usr/local/bin
# 相对路径
cd ../../usr/local/bin
</code></pre>
<ul>
<li>
<p>进入一个目录，可以使用绝对路径也可以使用相对路径，那我们应该在什么时候选择正确的方式进入某个目录呢。</p>
</li>
<li>
<p>完全就是凭直觉嘛，你觉得怎样方便就使用哪一个，而不用特意只使用某一种。</p>
</li>
<li>
<p>比如假设我当前在 <code>/usr/local/bin</code> 目录，我想进入上一级的 local 目录你说是使用 <code>cd ..</code> 方便还是 <code>cd /usr/local</code> 方便？而如果要进入的是 <code>usr</code> 目录，那么 <code>cd /usr</code> ，就比 <code>cd ../..</code> 方便一点了。</p>
</li>
</ul>
<p><strong>提示：在进行目录切换的过程中请多使用 <code>Tab</code> 键自动补全，可避免输入错误，连续按两次 <code>Tab</code> 可以显示全部候选结果。</strong></p>
<h4 id="新建空白文件">新建空白文件</h4>
<p>使用 <code>touch</code> 命令创建空白文件， <code>touch</code> 命令，主要作用是来更改已有文件的时间戳的（比如，最近访问时间，最近修改时间），但其在不加任何参数的情况下，只指定一个文件名，则可以创建一个指定文件名的空白文件（不会覆盖已有同名文件）。</p>
<p>创建名为 test 的空白文件：</p>
<pre><code class="language-bash">touch test
</code></pre>
<h4 id="新建目录文件夹">新建目录(文件夹)</h4>
<p>使用 <code>mkdir</code>（make directories）命令可以创建一个空目录(文件夹)，也可同时指定创建目录的权限属性。</p>
<p>创建名为“ mydir ”的空目录：</p>
<pre><code class="language-bash">mkdir mydir
</code></pre>
<p>使用 <code>-p</code> 参数，同时创建一个多级目录（这在安装软件、配置安装路径时非常有用）：</p>
<pre><code class="language-bash">mkdir -p father/son/grandson
</code></pre>
<p>这里使用的路径是相对路径，代表在当前目录下生成，当然我们直接以绝对路径的方式表示也是可以的。</p>
<p>还有一点需要注意的是，若当前目录已经创建了一个 test 文件（非文件夹），再使用 <code>mkdir test</code> 新建同名的文件夹，系统会报错文件已存在。</p>
<p><img src="https://i0.hdslb.com/bfs/album/3788cd4f3b3e2d4a842d46d31f193acaabbc37ab.png" alt="" loading="lazy"><br>
<strong>这符合 Linux 一切皆文件的理念。</strong></p>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#linux%E7%B3%BB%E7%BB%9F%E5%88%86%E6%94%AF">Linux系统分支：</a>
<ul>
<li><a href="#%E7%BB%88%E7%AB%AF%E7%9A%84%E6%89%93%E5%BC%80">终端的打开</a></li>
<li><a href="#%E9%87%8D%E8%A6%81%E5%BF%AB%E6%8D%B7%E9%94%AE">重要快捷键</a>
<ul>
<li><a href="#tab"><strong><code>[Tab]</code></strong></a></li>
<li><a href="#ctrlc"><strong><code>[Ctrl+c]</code></strong></a></li>
</ul>
</li>
<li><a href="#%E5%8E%86%E5%8F%B2%E8%BE%93%E5%85%A5%E5%91%BD%E4%BB%A4">历史输入命令</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6">使用通配符</a></li>
<li><a href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%B8%AE%E5%8A%A9">在命令行中获取帮助</a></li>
<li><a href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84">绝对路径</a></li>
<li><a href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84">相对路径</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E7%A9%BA%E7%99%BD%E6%96%87%E4%BB%B6">新建空白文件</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%A4%B9">新建目录(文件夹)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://KA-ASLant.GitHub.io/media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://KA-ASLant.GitHub.io/media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
  
  
</body>

</html>